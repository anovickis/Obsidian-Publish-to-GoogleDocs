/*
Publish to Google Docs - Obsidian Plugin
THIS IS A GENERATED/BUNDLED FILE. Do not edit directly.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PublishToGoogleDocsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  clientId: "",
  clientSecret: "",
  accessToken: "",
  refreshToken: "",
  tokenExpiry: 0,
  userEmail: "",
  defaultFolderId: ""
};
var GOOGLE_AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth";
var GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
var GOOGLE_USERINFO_URL = "https://www.googleapis.com/oauth2/v2/userinfo";
var DRIVE_UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3/files";
var DRIVE_FILES_URL = "https://www.googleapis.com/drive/v3/files";
var SCOPES = "https://www.googleapis.com/auth/drive.file";

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/auth.ts
var import_obsidian = require("obsidian");
var http = __toESM(require("http"));
var crypto = __toESM(require("crypto"));
function generateCodeVerifier() {
  const bytes = crypto.randomBytes(64);
  return bytes.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "").slice(0, 128);
}
function generateCodeChallenge(verifier) {
  const hash = crypto.createHash("sha256").update(verifier).digest();
  return hash.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function generateState() {
  return crypto.randomBytes(16).toString("hex");
}
async function startLoopbackServer(expectedState) {
  let resolveCode;
  let rejectCode;
  const codePromise = new Promise((resolve, reject) => {
    resolveCode = resolve;
    rejectCode = reject;
  });
  const server = http.createServer((req, res) => {
    const url = new URL(req.url || "/", `http://127.0.0.1`);
    const code = url.searchParams.get("code");
    const state = url.searchParams.get("state");
    const error = url.searchParams.get("error");
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    if (error) {
      res.end(`<html><body><h1>Authorization failed</h1>
                <p>Error: ${error}</p>
                <p>You can close this window.</p></body></html>`);
      rejectCode(new Error(`OAuth error: ${error}`));
    } else if (!code || state !== expectedState) {
      res.end(`<html><body><h1>Authorization failed</h1>
                <p>Invalid response from Google. Please try again.</p>
                <p>You can close this window.</p></body></html>`);
      rejectCode(new Error("Invalid OAuth callback: missing code or state mismatch"));
    } else {
      res.end(`<html><body><h1>Authorization successful!</h1>
                <p>You can close this window and return to Obsidian.</p></body></html>`);
      resolveCode(code);
    }
    setTimeout(() => {
      server.close();
    }, 1e3);
  });
  const port = await new Promise((resolve, reject) => {
    server.on("error", reject);
    server.listen(0, "127.0.0.1", () => {
      const address = server.address();
      const assignedPort = typeof address === "object" && address ? address.port : 0;
      resolve(assignedPort);
    });
  });
  const timeout = setTimeout(() => {
    server.close();
    rejectCode(new Error("OAuth timeout: no callback received within 120 seconds"));
  }, 12e4);
  codePromise.finally(() => clearTimeout(timeout));
  return { port, codePromise, server };
}
async function exchangeCodeForTokens(code, clientId, clientSecret, redirectUri, codeVerifier) {
  const body = new URLSearchParams({
    code,
    client_id: clientId,
    client_secret: clientSecret,
    redirect_uri: redirectUri,
    grant_type: "authorization_code",
    code_verifier: codeVerifier
  }).toString();
  const response = await (0, import_obsidian.requestUrl)({
    url: GOOGLE_TOKEN_URL,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });
  const data = response.json;
  if (!data.access_token) {
    throw new Error(`Token exchange failed: ${JSON.stringify(data)}`);
  }
  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token || "",
    tokenExpiry: Date.now() + (data.expires_in || 3600) * 1e3
  };
}
async function fetchUserEmail(accessToken) {
  try {
    const response = await (0, import_obsidian.requestUrl)({
      url: GOOGLE_USERINFO_URL,
      method: "GET",
      headers: { "Authorization": `Bearer ${accessToken}` }
    });
    return response.json.email || "authenticated";
  } catch (e) {
    return "authenticated";
  }
}
async function authenticate(settings) {
  if (!settings.clientId || !settings.clientSecret) {
    throw new Error("Please configure your Google Client ID and Client Secret in plugin settings.");
  }
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = generateCodeChallenge(codeVerifier);
  const state = generateState();
  const { port, codePromise, server } = await startLoopbackServer(state);
  const redirectUri = `http://127.0.0.1:${port}`;
  const params = new URLSearchParams({
    client_id: settings.clientId,
    redirect_uri: redirectUri,
    response_type: "code",
    scope: SCOPES,
    code_challenge: codeChallenge,
    code_challenge_method: "S256",
    state,
    access_type: "offline",
    prompt: "select_account consent"
    // force account chooser + always get refresh token
  });
  if (settings.userEmail) {
    params.set("login_hint", settings.userEmail);
  }
  const authUrl = `${GOOGLE_AUTH_URL}?${params.toString()}`;
  window.open(authUrl);
  new import_obsidian.Notice(`OAuth: waiting for callback on port ${port}...`);
  try {
    const code = await codePromise;
    new import_obsidian.Notice("OAuth: received auth code, exchanging for tokens...");
    console.log("OAuth: auth code received, length:", code.length);
    const tokens = await exchangeCodeForTokens(
      code,
      settings.clientId,
      settings.clientSecret,
      redirectUri,
      codeVerifier
    );
    new import_obsidian.Notice("OAuth: tokens received, fetching user info...");
    console.log("OAuth: got access token, has refresh:", !!tokens.refreshToken);
    const userEmail = await fetchUserEmail(tokens.accessToken);
    new import_obsidian.Notice(`OAuth: signed in as ${userEmail}`);
    return { ...tokens, userEmail };
  } catch (err) {
    server.close();
    console.error("OAuth error:", err);
    new import_obsidian.Notice(`OAuth error: ${err.message}`);
    throw err;
  }
}
async function refreshAccessToken(settings) {
  if (!settings.refreshToken) {
    throw new Error("No refresh token available. Please sign in again.");
  }
  const body = new URLSearchParams({
    client_id: settings.clientId,
    client_secret: settings.clientSecret,
    refresh_token: settings.refreshToken,
    grant_type: "refresh_token"
  }).toString();
  const response = await (0, import_obsidian.requestUrl)({
    url: GOOGLE_TOKEN_URL,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });
  const data = response.json;
  if (!data.access_token) {
    throw new Error(`Token refresh failed: ${JSON.stringify(data)}`);
  }
  return {
    accessToken: data.access_token,
    tokenExpiry: Date.now() + (data.expires_in || 3600) * 1e3
  };
}
async function getValidToken(settings, saveFn) {
  if (!settings.refreshToken) {
    const result = await authenticate(settings);
    settings.accessToken = result.accessToken;
    settings.refreshToken = result.refreshToken;
    settings.tokenExpiry = result.tokenExpiry;
    settings.userEmail = result.userEmail;
    await saveFn();
    return result.accessToken;
  }
  if (settings.accessToken && Date.now() < settings.tokenExpiry - 6e4) {
    return settings.accessToken;
  }
  try {
    const result = await refreshAccessToken(settings);
    settings.accessToken = result.accessToken;
    settings.tokenExpiry = result.tokenExpiry;
    await saveFn();
    return result.accessToken;
  } catch (err) {
    new import_obsidian.Notice("Token refresh failed. Please sign in again.");
    const result = await authenticate(settings);
    settings.accessToken = result.accessToken;
    settings.refreshToken = result.refreshToken;
    settings.tokenExpiry = result.tokenExpiry;
    settings.userEmail = result.userEmail;
    await saveFn();
    return result.accessToken;
  }
}

// src/settings.ts
var PublishSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Publish to Google Docs" });
    containerEl.createEl("h3", { text: "Google Cloud Credentials" });
    containerEl.createEl("p", {
      text: "You need your own Google Cloud project with OAuth credentials. See setup instructions below.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Client ID").setDesc("From Google Cloud Console \u2192 APIs & Services \u2192 Credentials").addText(
      (text) => text.setPlaceholder("xxxx.apps.googleusercontent.com").setValue(this.plugin.settings.clientId).onChange(async (value) => {
        this.plugin.settings.clientId = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Client Secret").setDesc("Keep this private \u2014 stored locally in your vault").addText((text) => {
      text.setPlaceholder("GOCSPX-...").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
        this.plugin.settings.clientSecret = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    containerEl.createEl("h3", { text: "Authentication" });
    const authStatus = this.plugin.settings.refreshToken ? `Signed in as: ${this.plugin.settings.userEmail || "unknown"}` : "Not signed in";
    const authSetting = new import_obsidian2.Setting(containerEl).setName("Status").setDesc(authStatus);
    if (this.plugin.settings.refreshToken) {
      authSetting.addButton(
        (btn) => btn.setButtonText("Sign out").onClick(async () => {
          this.plugin.settings.accessToken = "";
          this.plugin.settings.refreshToken = "";
          this.plugin.settings.tokenExpiry = 0;
          this.plugin.settings.userEmail = "";
          await this.plugin.saveSettings();
          new import_obsidian2.Notice("Signed out of Google.");
          this.display();
        })
      );
    } else {
      authSetting.addButton(
        (btn) => btn.setButtonText("Sign in with Google").setCta().onClick(async () => {
          if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret) {
            new import_obsidian2.Notice("Please enter your Client ID and Client Secret first.");
            return;
          }
          try {
            const result = await authenticate(this.plugin.settings);
            this.plugin.settings.accessToken = result.accessToken;
            this.plugin.settings.refreshToken = result.refreshToken;
            this.plugin.settings.tokenExpiry = result.tokenExpiry;
            this.plugin.settings.userEmail = result.userEmail;
            await this.plugin.saveSettings();
            new import_obsidian2.Notice(`Signed in as ${result.userEmail}`);
            this.display();
          } catch (err) {
            new import_obsidian2.Notice(`Sign-in failed: ${err.message}`);
          }
        })
      );
    }
    containerEl.createEl("h3", { text: "Google Drive Options" });
    new import_obsidian2.Setting(containerEl).setName("Target Folder ID").setDesc(
      "Optional. ID of the Google Drive folder where new docs are created. Leave blank for the root of My Drive. Find the ID in the folder URL: drive.google.com/drive/folders/THIS_PART"
    ).addText(
      (text) => text.setPlaceholder("1a2b3c4d5e...").setValue(this.plugin.settings.defaultFolderId).onChange(async (value) => {
        this.plugin.settings.defaultFolderId = value.trim();
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Setup Instructions" });
    const details = containerEl.createEl("details");
    details.createEl("summary", { text: "How to create Google Cloud OAuth credentials" });
    const steps = details.createEl("ol");
    const instructions = [
      'Go to <a href="https://console.cloud.google.com">console.cloud.google.com</a>',
      "Create a new project (or select an existing one)",
      "Navigate to <b>APIs & Services \u2192 Library</b>",
      "Search for and enable the <b>Google Drive API</b>",
      "Navigate to <b>APIs & Services \u2192 Credentials</b>",
      "Click <b>Create Credentials \u2192 OAuth client ID</b>",
      "Choose application type: <b>Desktop app</b>",
      'Give it a name (e.g., "Obsidian Publish")',
      "Click <b>Create</b>",
      "Copy the <b>Client ID</b> and <b>Client Secret</b> into the fields above",
      'You may need to configure the <b>OAuth consent screen</b> first (choose "External" type, add yourself as a test user)'
    ];
    for (const instruction of instructions) {
      const li = steps.createEl("li");
      li.innerHTML = instruction;
    }
    const securityNote = details.createEl("p");
    securityNote.innerHTML = "<b>Security note:</b> Your credentials are stored locally in <code>.obsidian/plugins/publish-to-google-docs/data.json</code>. If your vault syncs via cloud storage (OneDrive, Dropbox, etc.), this file will be synced too. The plugin only requests the narrowest possible scope (<code>drive.file</code>) which limits access to files created by this plugin.";
  }
};

// src/publisher.ts
var import_obsidian5 = require("obsidian");

// src/converter.ts
var import_obsidian3 = require("obsidian");
function stripFrontmatter(markdown) {
  const match = markdown.match(/^---\r?\n[\s\S]*?\r?\n---\r?\n?/);
  return match ? markdown.slice(match[0].length) : markdown;
}
function extractCodeBlocks(markdown) {
  const blocks = [];
  let cleaned = markdown.replace(/```[\s\S]*?```/g, (match) => {
    const placeholder = `GDOCS_CB${blocks.length}`;
    blocks.push({ placeholder, original: match });
    return placeholder;
  });
  cleaned = cleaned.replace(/`[^`\n]+`/g, (match) => {
    const placeholder = `GDOCS_CI${blocks.length}`;
    blocks.push({ placeholder, original: match });
    return placeholder;
  });
  return { cleaned, blocks };
}
function restoreExtractions(text, extractions) {
  let result = text;
  for (let i = extractions.length - 1; i >= 0; i--) {
    result = result.split(extractions[i].placeholder).join(extractions[i].original);
  }
  return result;
}
function extractMath(markdown) {
  const math = [];
  let cleaned = markdown.replace(/\$\$([\s\S]+?)\$\$/g, (match, latex) => {
    const placeholder = `GDOCS_MD${math.length}`;
    math.push({ placeholder, original: match, isDisplay: true, latex: latex.trim() });
    return placeholder;
  });
  cleaned = cleaned.replace(/(?<!\$)\$(?!\$|\s)([^$\n]+?)(?<!\s)\$(?!\$)/g, (match, latex) => {
    const placeholder = `GDOCS_MI${math.length}`;
    math.push({ placeholder, original: match, isDisplay: false, latex: latex.trim() });
    return placeholder;
  });
  return { cleaned, math };
}
function extractImageEmbeds(markdown) {
  const images = [];
  let cleaned = markdown.replace(/!\[\[([^\]|]+?)(?:\|([^\]]*))?\]\]/g, (match, path, sizeOrAlt) => {
    const placeholder = `GDOCS_IM${images.length}`;
    const vaultPath = path.trim();
    const isSvg = vaultPath.toLowerCase().endsWith(".svg");
    let width = null;
    let alt = "";
    if (sizeOrAlt) {
      if (/^\d+(?:x\d+)?$/.test(sizeOrAlt.trim())) {
        width = sizeOrAlt.trim().split("x")[0];
      } else {
        alt = sizeOrAlt.trim();
      }
    }
    images.push({ placeholder, original: match, vaultPath, alt, width, isSvg });
    return placeholder;
  });
  cleaned = cleaned.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, path) => {
    const placeholder = `GDOCS_IM${images.length}`;
    const vaultPath = decodeURIComponent(path.trim());
    const isSvg = vaultPath.toLowerCase().endsWith(".svg");
    images.push({ placeholder, original: match, vaultPath, alt: alt || "", width: null, isSvg });
    return placeholder;
  });
  return { cleaned, images };
}
async function renderMarkdownToHtml(app, markdown, sourcePath) {
  const container = document.createElement("div");
  const component = new import_obsidian3.Component();
  component.load();
  try {
    await import_obsidian3.MarkdownRenderer.render(app, markdown, container, sourcePath, component);
    return container.innerHTML;
  } finally {
    component.unload();
  }
}
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function restoreMathInHtml(html, math) {
  let result = html;
  for (const m of math) {
    const latexHtml = escapeHtml(m.latex);
    const restored = m.isDisplay ? `\\[${latexHtml}\\]` : `\\(${latexHtml}\\)`;
    result = result.split(m.placeholder).join(restored);
  }
  return result;
}
async function processAndRestoreImages(html, imageExtractions, app, file, uploadImageFn) {
  let result = html;
  for (let i = 0; i < imageExtractions.length; i += 5) {
    const batch = imageExtractions.slice(i, i + 5);
    const uploadResults = await Promise.all(
      batch.map(async (img) => {
        try {
          const imageFile = app.metadataCache.getFirstLinkpathDest(
            img.vaultPath,
            file.path
          );
          if (!imageFile) {
            console.warn(`Image not found in vault: ${img.vaultPath}`);
            return { img, tag: `<em>[Image not found: ${img.vaultPath}]</em>` };
          }
          let imageData = await app.vault.readBinary(imageFile);
          let mimeType = img.isSvg ? "image/png" : `image/${imageFile.extension}`;
          let fileName = imageFile.name;
          if (img.isSvg) {
            imageData = await rasterizeSvgToPng(imageData);
            fileName = fileName.replace(/\.svg$/i, ".png");
          }
          if (mimeType === "image/jpg") mimeType = "image/jpeg";
          const publicUrl = await uploadImageFn(imageData, fileName, mimeType);
          let tag = `<img src="${publicUrl}" alt="${escapeHtml(img.alt || imageFile.basename)}"`;
          if (img.width) tag += ` width="${img.width}"`;
          tag += ` style="max-width:100%;">`;
          return { img, tag };
        } catch (err) {
          console.error(`Failed to process image ${img.vaultPath}:`, err);
          return { img, tag: `<em>[Failed to upload: ${img.vaultPath}]</em>` };
        }
      })
    );
    for (const r of uploadResults) {
      const blockPattern = `<p>${r.img.placeholder}</p>`;
      if (result.includes(blockPattern)) {
        result = result.split(blockPattern).join(r.tag);
      } else {
        result = result.split(r.img.placeholder).join(r.tag);
      }
    }
  }
  return result;
}
async function rasterizeSvgToPng(svgData) {
  const svgString = new TextDecoder().decode(svgData);
  let width = 800;
  let height = 600;
  const viewBoxMatch = svgString.match(/viewBox="([^"]+)"/);
  if (viewBoxMatch) {
    const parts = viewBoxMatch[1].split(/[\s,]+/).map(Number);
    if (parts.length >= 4) {
      width = parts[2];
      height = parts[3];
    }
  }
  const widthMatch = svgString.match(/width="(\d+(?:\.\d+)?)(?:px)?"/);
  const heightMatch = svgString.match(/height="(\d+(?:\.\d+)?)(?:px)?"/);
  if (widthMatch) width = parseFloat(widthMatch[1]);
  if (heightMatch) height = parseFloat(heightMatch[1]);
  const scale = 2;
  const canvasWidth = Math.round(width * scale);
  const canvasHeight = Math.round(height * scale);
  return new Promise((resolve, reject) => {
    const img = new Image();
    const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    img.onload = () => {
      try {
        const canvas = document.createElement("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas 2d context"));
          return;
        }
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
        canvas.toBlob((pngBlob) => {
          if (!pngBlob) {
            reject(new Error("Canvas toBlob returned null"));
            return;
          }
          pngBlob.arrayBuffer().then(resolve).catch(reject);
        }, "image/png");
      } finally {
        URL.revokeObjectURL(url);
      }
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error("Failed to load SVG into Image element"));
    };
    img.src = url;
  });
}
var CALLOUT_COLORS = {
  note: "#448aff",
  abstract: "#00bcd4",
  summary: "#00bcd4",
  info: "#2196f3",
  tip: "#00bfa5",
  hint: "#00bfa5",
  success: "#00c853",
  check: "#00c853",
  question: "#ff9800",
  help: "#ff9800",
  warning: "#ff9100",
  caution: "#ff9100",
  failure: "#ff5252",
  danger: "#ff5252",
  error: "#ff5252",
  bug: "#ff5252",
  example: "#7c4dff",
  quote: "#9e9e9e",
  cite: "#9e9e9e"
};
function cleanHtmlForGoogleDocs(html) {
  let result = html;
  result = result.replace(
    /<div[^>]*data-callout="([^"]*)"[^>]*class="[^"]*callout[^"]*"[^>]*>([\s\S]*?)<\/div>\s*<\/div>\s*<\/div>/gi,
    (_, type, content) => {
      const color = CALLOUT_COLORS[type.toLowerCase()] || "#448aff";
      const cleanContent = content.replace(/<div[^>]*class="[^"]*callout-title[^"]*"[^>]*>/gi, "<b>").replace(/<div[^>]*class="[^"]*callout-content[^"]*"[^>]*>/gi, "").replace(/<\/div>/gi, "</b><br/>");
      return `<table style="border-left:4px solid ${color};background:#f8f9fa;width:100%;margin:12px 0;">
                <tr><td style="padding:12px;">${cleanContent}</td></tr></table>`;
    }
  );
  result = result.replace(
    /<a[^>]*class="[^"]*internal-link[^"]*"[^>]*>(.*?)<\/a>/gi,
    "<b>$1</b>"
  );
  result = result.replace(
    /<pre>/gi,
    `<pre style="background:#f5f5f5;padding:16px;border-radius:4px;font-family:'Courier New',monospace;white-space:pre;overflow-x:auto;font-size:13px;">`
  );
  result = result.replace(
    /<code>/gi,
    `<code style="background:#f5f5f5;padding:2px 4px;border-radius:3px;font-family:'Courier New',monospace;font-size:13px;">`
  );
  result = result.replace(
    /<blockquote>/gi,
    '<blockquote style="border-left:4px solid #ccc;padding-left:16px;margin-left:0;color:#666;">'
  );
  result = result.replace(
    /<table(?![^>]*style)/gi,
    '<table style="border-collapse:collapse;width:100%;margin:12px 0;"'
  );
  result = result.replace(
    /<th(?![^>]*style)/gi,
    '<th style="border:1px solid #ddd;padding:8px;background:#f5f5f5;text-align:left;"'
  );
  result = result.replace(
    /<td(?![^>]*style)/gi,
    '<td style="border:1px solid #ddd;padding:8px;"'
  );
  result = result.replace(/\s+class="[^"]*"/gi, "");
  result = result.replace(/\s+data-[a-z-]+="[^"]*"/gi, "");
  result = result.replace(/<p>\s*<\/p>/gi, "");
  result = result.replace(/<mjx-container[^>]*>[\s\S]*?<\/mjx-container>/gi, "");
  return result;
}
async function convertNoteToHtml(app, file, uploadImageFn) {
  const rawMarkdown = await app.vault.read(file);
  const markdown = stripFrontmatter(rawMarkdown);
  const { cleaned: noCodeMd, blocks: codeBlocks } = extractCodeBlocks(markdown);
  const { cleaned: noMathMd, math: mathExtractions } = extractMath(noCodeMd);
  const { cleaned: noImgMd, images: imageExtractions } = extractImageEmbeds(noMathMd);
  const renderMd = restoreExtractions(noImgMd, codeBlocks);
  console.log(`convertNoteToHtml: extracted ${mathExtractions.length} math, ${imageExtractions.length} images`);
  let html = await renderMarkdownToHtml(app, renderMd, file.path);
  html = restoreMathInHtml(html, mathExtractions);
  html = await processAndRestoreImages(html, imageExtractions, app, file, uploadImageFn);
  html = cleanHtmlForGoogleDocs(html);
  const title = file.basename;
  return `<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>${title}</title>
</head>
<body style="font-family:Arial,sans-serif;max-width:800px;margin:auto;line-height:1.6;">
<h1>${title}</h1>
${html}
</body>
</html>`;
}

// src/google-api.ts
var import_obsidian4 = require("obsidian");
function concatArrayBuffers(...buffers) {
  const totalLength = buffers.reduce((sum, buf) => sum + buf.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const buf of buffers) {
    result.set(new Uint8Array(buf), offset);
    offset += buf.byteLength;
  }
  return result.buffer;
}
function stringToArrayBuffer(str) {
  return new TextEncoder().encode(str).buffer;
}
function extractDocId(url) {
  const match = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
  return match ? match[1] : null;
}
async function createGoogleDoc(accessToken, name, htmlContent, folderId) {
  const boundary = "----PublishToGDocs" + Date.now();
  const metadata = {
    name,
    mimeType: "application/vnd.google-apps.document"
  };
  if (folderId) {
    metadata.parents = [folderId];
  }
  const body = [
    `--${boundary}\r
`,
    "Content-Type: application/json; charset=UTF-8\r\n\r\n",
    JSON.stringify(metadata),
    `\r
--${boundary}\r
`,
    "Content-Type: text/html; charset=UTF-8\r\n\r\n",
    htmlContent,
    `\r
--${boundary}--`
  ].join("");
  const response = await (0, import_obsidian4.requestUrl)({
    url: `${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id,name,webViewLink,mimeType`,
    method: "POST",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Content-Type": `multipart/related; boundary=${boundary}`
    },
    body
  });
  const data = response.json;
  if (!data.id) {
    throw new Error(`Failed to create Google Doc: ${JSON.stringify(data)}`);
  }
  return {
    id: data.id,
    name: data.name,
    webViewLink: data.webViewLink,
    mimeType: data.mimeType
  };
}
async function uploadImageToDrive(accessToken, imageData, fileName, mimeType, folderId) {
  const boundary = "----PublishToGDocsImg" + Date.now() + Math.random().toString(36).slice(2);
  const metadata = { name: fileName };
  if (folderId) {
    metadata.parents = [folderId];
  }
  const metadataPart = [
    `--${boundary}\r
`,
    "Content-Type: application/json; charset=UTF-8\r\n\r\n",
    JSON.stringify(metadata),
    "\r\n"
  ].join("");
  const imagePart = [
    `--${boundary}\r
`,
    `Content-Type: ${mimeType}\r
`,
    "Content-Transfer-Encoding: binary\r\n\r\n"
  ].join("");
  const closing = `\r
--${boundary}--`;
  const body = concatArrayBuffers(
    stringToArrayBuffer(metadataPart),
    stringToArrayBuffer(imagePart),
    imageData,
    stringToArrayBuffer(closing)
  );
  const uploadResponse = await (0, import_obsidian4.requestUrl)({
    url: `${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id`,
    method: "POST",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Content-Type": `multipart/related; boundary=${boundary}`
    },
    body
  });
  const fileId = uploadResponse.json.id;
  if (!fileId) {
    throw new Error(`Image upload failed: ${JSON.stringify(uploadResponse.json)}`);
  }
  await (0, import_obsidian4.requestUrl)({
    url: `${DRIVE_FILES_URL}/${fileId}/permissions`,
    method: "POST",
    headers: {
      "Authorization": `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ role: "reader", type: "anyone" })
  });
  return `https://drive.google.com/uc?id=${fileId}&export=download`;
}

// src/publisher.ts
var UpdateChoiceModal = class extends import_obsidian5.Modal {
  constructor(app, resolveFn) {
    super(app);
    this.resolveFn = resolveFn;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("publish-gdocs-modal");
    contentEl.createEl("h3", { text: "Publish to Google Docs" });
    contentEl.createEl("p", {
      text: "This note already has a linked Google Doc. What would you like to do?"
    });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const updateBtn = buttonContainer.createEl("button", { text: "Update existing" });
    updateBtn.addClass("mod-cta");
    updateBtn.addEventListener("click", () => {
      this.resolveFn("update");
      this.close();
    });
    const newBtn = buttonContainer.createEl("button", { text: "Create new" });
    newBtn.addEventListener("click", () => {
      this.resolveFn("new");
      this.close();
    });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => {
      this.resolveFn(null);
      this.close();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
function showUpdateChoiceModal(app) {
  return new Promise((resolve) => {
    new UpdateChoiceModal(app, resolve).open();
  });
}
async function publishNote(plugin, file) {
  var _a;
  if (!plugin.settings.clientId || !plugin.settings.clientSecret) {
    new import_obsidian5.Notice("Please configure Google API credentials in the plugin settings first.");
    const settingTab = plugin.app.setting;
    if (settingTab) {
      settingTab.open();
      settingTab.openTabById("publish-to-google-docs");
    }
    return;
  }
  let token;
  try {
    token = await getValidToken(plugin.settings, () => plugin.saveSettings());
  } catch (err) {
    new import_obsidian5.Notice(`Authentication failed: ${err.message}`);
    return;
  }
  let existingUrl = null;
  const cache = plugin.app.metadataCache.getFileCache(file);
  if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.google_doc) {
    existingUrl = cache.frontmatter.google_doc;
  }
  let action = "new";
  if (existingUrl) {
    const choice = await showUpdateChoiceModal(plugin.app);
    if (choice === null) return;
    action = choice;
  }
  const progressNotice = new import_obsidian5.Notice("Publishing to Google Docs...", 0);
  try {
    const uploadImage = async (data, name, mime) => {
      return uploadImageToDrive(
        token,
        data,
        name,
        mime,
        plugin.settings.defaultFolderId || void 0
      );
    };
    const html = await convertNoteToHtml(plugin.app, file, uploadImage);
    const docName = file.basename;
    const result = await createGoogleDoc(
      token,
      docName,
      html,
      plugin.settings.defaultFolderId || void 0
    );
    if (action === "update" && existingUrl) {
      const oldId = extractDocId(existingUrl);
      if (oldId) {
        try {
          await (0, import_obsidian5.requestUrl)({
            url: `https://www.googleapis.com/drive/v3/files/${oldId}`,
            method: "PATCH",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ trashed: true })
          });
        } catch (err) {
          console.warn("Failed to trash old Google Doc:", err);
        }
      }
    }
    await plugin.app.fileManager.processFrontMatter(file, (fm) => {
      fm.google_doc = result.webViewLink;
    });
    progressNotice.hide();
    new import_obsidian5.Notice(`Published to Google Docs!
${result.webViewLink}`, 1e4);
    window.open(result.webViewLink);
  } catch (err) {
    progressNotice.hide();
    const status = err.status;
    if (status === 401 || status === 403) {
      new import_obsidian5.Notice("Auth token expired. Refreshing and retrying...");
      plugin.settings.accessToken = "";
      plugin.settings.tokenExpiry = 0;
      await plugin.saveSettings();
      try {
        await publishNote(plugin, file);
      } catch (retryErr) {
        new import_obsidian5.Notice(`Publish failed after retry: ${retryErr.message}`);
      }
      return;
    }
    new import_obsidian5.Notice(`Publish failed: ${err.message}`);
    console.error("Publish to Google Docs error:", err);
  }
}

// src/main.ts
var PublishToGoogleDocsPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PublishSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!(file instanceof import_obsidian6.TFile)) return;
        if (file.extension !== "md") return;
        menu.addItem((item) => {
          item.setTitle("Publish to Google Docs").setIcon("upload-cloud").onClick(async () => {
            try {
              await publishNote(this, file);
            } catch (err) {
              console.error("Publish to Google Docs error:", err);
              new import_obsidian6.Notice(`Publish failed: ${err.message}`);
            }
          });
        });
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3R5cGVzLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvYXV0aC50cyIsICJzcmMvcHVibGlzaGVyLnRzIiwgInNyYy9jb252ZXJ0ZXIudHMiLCAic3JjL2dvb2dsZS1hcGkudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIG1haW4udHMgXHUyMDE0IFBsdWdpbiBlbnRyeSBwb2ludCBmb3IgXCJQdWJsaXNoIHRvIEdvb2dsZSBEb2NzXCJcbi8vXG4vLyBSZWdpc3RlcnMgdGhlIGZpbGUtbWVudSBjb250ZXh0IG1lbnUgaXRlbSBhbmQgc2V0dGluZ3MgdGFiLlxuLy8gVGhlIGFjdHVhbCBwdWJsaXNoIGxvZ2ljIGxpdmVzIGluIHB1Ymxpc2hlci50cy5cblxuaW1wb3J0IHtcbiAgICBOb3RpY2UsXG4gICAgUGx1Z2luLFxuICAgIFRGaWxlLFxuICAgIFRBYnN0cmFjdEZpbGUsXG59IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFBsdWdpblNldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBQdWJsaXNoU2V0dGluZ1RhYiB9IGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgcHVibGlzaE5vdGUgfSBmcm9tICcuL3B1Ymxpc2hlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1Ymxpc2hUb0dvb2dsZURvY3NQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBQbHVnaW5TZXR0aW5ncyA9IERFRkFVTFRfU0VUVElOR1M7XG5cbiAgICBhc3luYyBvbmxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgUHVibGlzaFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyBSZWdpc3RlciBmaWxlLW1lbnUgZXZlbnQ6IHJpZ2h0LWNsaWNrIG9uIC5tZCBmaWxlIFx1MjE5MiBcIlB1Ymxpc2ggdG8gR29vZ2xlIERvY3NcIlxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtbWVudScsIChtZW51LCBmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBzaG93IGZvciBtYXJrZG93biBmaWxlc1xuICAgICAgICAgICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5leHRlbnNpb24gIT09ICdtZCcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdQdWJsaXNoIHRvIEdvb2dsZSBEb2NzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCd1cGxvYWQtY2xvdWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hOb3RlKHRoaXMsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQdWJsaXNoIHRvIEdvb2dsZSBEb2NzIGVycm9yOicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFB1Ymxpc2ggZmFpbGVkOiAkeyhlcnIgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpOiB2b2lkIHtcbiAgICAgICAgLy8gTm8gcGVyc2lzdGVudCByZXNvdXJjZXMgdG8gY2xlYW4gdXBcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG4iLCAiLy8gdHlwZXMudHMgXHUyMDE0IFNoYXJlZCBpbnRlcmZhY2VzIGFuZCBjb25zdGFudHMgZm9yIFB1Ymxpc2ggdG8gR29vZ2xlIERvY3MgcGx1Z2luXG5cbi8vIC0tLS0gUGx1Z2luIFNldHRpbmdzIC0tLS1cblxuZXhwb3J0IGludGVyZmFjZSBQbHVnaW5TZXR0aW5ncyB7XG4gICAgY2xpZW50SWQ6IHN0cmluZztcbiAgICBjbGllbnRTZWNyZXQ6IHN0cmluZztcbiAgICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xuICAgIHJlZnJlc2hUb2tlbjogc3RyaW5nO1xuICAgIHRva2VuRXhwaXJ5OiBudW1iZXI7ICAgICAgIC8vIGVwb2NoIG1zIHdoZW4gYWNjZXNzIHRva2VuIGV4cGlyZXNcbiAgICB1c2VyRW1haWw6IHN0cmluZzsgICAgICAgICAvLyBlbWFpbCBvZiB0aGUgYXV0aGVudGljYXRlZCBHb29nbGUgYWNjb3VudFxuICAgIGRlZmF1bHRGb2xkZXJJZDogc3RyaW5nOyAgIC8vIEdvb2dsZSBEcml2ZSBmb2xkZXIgSUQgZm9yIG5ldyBkb2NzIChvcHRpb25hbClcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpblNldHRpbmdzID0ge1xuICAgIGNsaWVudElkOiAnJyxcbiAgICBjbGllbnRTZWNyZXQ6ICcnLFxuICAgIGFjY2Vzc1Rva2VuOiAnJyxcbiAgICByZWZyZXNoVG9rZW46ICcnLFxuICAgIHRva2VuRXhwaXJ5OiAwLFxuICAgIHVzZXJFbWFpbDogJycsXG4gICAgZGVmYXVsdEZvbGRlcklkOiAnJyxcbn07XG5cbi8vIC0tLS0gR29vZ2xlIEFQSSBFbmRwb2ludHMgLS0tLVxuXG5leHBvcnQgY29uc3QgR09PR0xFX0FVVEhfVVJMID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi92Mi9hdXRoJztcbmV4cG9ydCBjb25zdCBHT09HTEVfVE9LRU5fVVJMID0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJztcbmV4cG9ydCBjb25zdCBHT09HTEVfVVNFUklORk9fVVJMID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92Mi91c2VyaW5mbyc7XG5leHBvcnQgY29uc3QgRFJJVkVfVVBMT0FEX1VSTCA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS91cGxvYWQvZHJpdmUvdjMvZmlsZXMnO1xuZXhwb3J0IGNvbnN0IERSSVZFX0ZJTEVTX1VSTCA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcyc7XG5cbi8vIE5hcnJvd2VzdCBzY29wZTogb25seSBhY2Nlc3MgZmlsZXMgdGhpcyBhcHAgY3JlYXRlZFxuZXhwb3J0IGNvbnN0IFNDT1BFUyA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmZpbGUnO1xuXG4vLyAtLS0tIENvbnZlcnNpb24gVHlwZXMgLS0tLVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZE1hdGgge1xuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmc7ICAgLy8gZS5nLiwgJSVNQVRIXzAlJVxuICAgIHJhdzogc3RyaW5nOyAgICAgICAgICAgLy8gb3JpZ2luYWwgTGFUZVggaW5jbHVkaW5nIGRlbGltaXRlcnMgKCQuLi4kIG9yICQkLi4uJCQpXG4gICAgZGlzcGxheTogYm9vbGVhbjsgICAgICAvLyB0cnVlIGZvciAkJC4uLiQkLCBmYWxzZSBmb3IgJC4uLiRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbEltYWdlIHtcbiAgICBpbWdUYWc6IHN0cmluZzsgICAgICAgIC8vIHRoZSBmdWxsIDxpbWcgLi4uPiB0YWcgaW4gSFRNTFxuICAgIHNyYzogc3RyaW5nOyAgICAgICAgICAgLy8gdGhlIHNyYyBhdHRyaWJ1dGUgdmFsdWVcbiAgICB2YXVsdFBhdGg6IHN0cmluZzsgICAgIC8vIHJlc29sdmVkIHZhdWx0LXJlbGF0aXZlIHBhdGhcbiAgICBpc1N2ZzogYm9vbGVhbjsgICAgICAgIC8vIHdoZXRoZXIgdGhlIHNvdXJjZSBpcyBhbiBTVkdcbn1cblxuLy8gLS0tLSBHb29nbGUgQVBJIFJlc3BvbnNlIFR5cGVzIC0tLS1cblxuZXhwb3J0IGludGVyZmFjZSBEcml2ZUZpbGVSZXNwb25zZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgd2ViVmlld0xpbms6IHN0cmluZztcbiAgICBtaW1lVHlwZTogc3RyaW5nO1xufVxuIiwgIi8vIHNldHRpbmdzLnRzIFx1MjAxNCBQbHVnaW4gc2V0dGluZ3MgdGFiXG4vL1xuLy8gUHJvdmlkZXMgVUkgZm9yOiBHb29nbGUgQ2xvdWQgY3JlZGVudGlhbHMgKGNsaWVudCBJRCwgc2VjcmV0KSxcbi8vIGF1dGhlbnRpY2F0aW9uIHN0YXR1cyArIHNpZ24taW4vb3V0LCBEcml2ZSBmb2xkZXIgdGFyZ2V0LFxuLy8gYW5kIHNldHVwIGluc3RydWN0aW9ucy5cblxuaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSBQdWJsaXNoVG9Hb29nbGVEb2NzUGx1Z2luIGZyb20gJy4vbWFpbic7XG5pbXBvcnQgeyBhdXRoZW50aWNhdGUgfSBmcm9tICcuL2F1dGgnO1xuXG5leHBvcnQgY2xhc3MgUHVibGlzaFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IFB1Ymxpc2hUb0dvb2dsZURvY3NQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQdWJsaXNoVG9Hb29nbGVEb2NzUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICAvLyAtLS0tIEhlYWRlciAtLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1B1Ymxpc2ggdG8gR29vZ2xlIERvY3MnIH0pO1xuXG4gICAgICAgIC8vIC0tLS0gR29vZ2xlIENsb3VkIENyZWRlbnRpYWxzIC0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnR29vZ2xlIENsb3VkIENyZWRlbnRpYWxzJyB9KTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICB0ZXh0OiAnWW91IG5lZWQgeW91ciBvd24gR29vZ2xlIENsb3VkIHByb2plY3Qgd2l0aCBPQXV0aCBjcmVkZW50aWFscy4gU2VlIHNldHVwIGluc3RydWN0aW9ucyBiZWxvdy4nLFxuICAgICAgICAgICAgY2xzOiAnc2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ2xpZW50IElEJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdGcm9tIEdvb2dsZSBDbG91ZCBDb25zb2xlIFx1MjE5MiBBUElzICYgU2VydmljZXMgXHUyMTkyIENyZWRlbnRpYWxzJylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd4eHh4LmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNsaWVudElkKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGllbnRJZCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ2xpZW50IFNlY3JldCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnS2VlcCB0aGlzIHByaXZhdGUgXHUyMDE0IHN0b3JlZCBsb2NhbGx5IGluIHlvdXIgdmF1bHQnKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignR09DU1BYLS4uLicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGllbnRTZWNyZXQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNsaWVudFNlY3JldCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBNYXNrIHRoZSBpbnB1dCBsaWtlIGEgcGFzc3dvcmQgZmllbGRcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tIEF1dGhlbnRpY2F0aW9uIFN0YXR1cyAtLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0F1dGhlbnRpY2F0aW9uJyB9KTtcblxuICAgICAgICBjb25zdCBhdXRoU3RhdHVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFRva2VuXG4gICAgICAgICAgICA/IGBTaWduZWQgaW4gYXM6ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlckVtYWlsIHx8ICd1bmtub3duJ31gXG4gICAgICAgICAgICA6ICdOb3Qgc2lnbmVkIGluJztcblxuICAgICAgICBjb25zdCBhdXRoU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1N0YXR1cycpXG4gICAgICAgICAgICAuc2V0RGVzYyhhdXRoU3RhdHVzKTtcblxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAvLyBTaWduIG91dCBidXR0b25cbiAgICAgICAgICAgIGF1dGhTZXR0aW5nLmFkZEJ1dHRvbigoYnRuKSA9PlxuICAgICAgICAgICAgICAgIGJ0blxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnU2lnbiBvdXQnKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hY2Nlc3NUb2tlbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFRva2VuID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b2tlbkV4cGlyeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyRW1haWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnU2lnbmVkIG91dCBvZiBHb29nbGUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmVmcmVzaCB0aGUgc2V0dGluZ3MgVUlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2lnbiBpbiBidXR0b25cbiAgICAgICAgICAgIGF1dGhTZXR0aW5nLmFkZEJ1dHRvbigoYnRuKSA9PlxuICAgICAgICAgICAgICAgIGJ0blxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnU2lnbiBpbiB3aXRoIEdvb2dsZScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLmNsaWVudElkIHx8ICF0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2UgZW50ZXIgeW91ciBDbGllbnQgSUQgYW5kIENsaWVudCBTZWNyZXQgZmlyc3QuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGUodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFjY2Vzc1Rva2VuID0gcmVzdWx0LmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZnJlc2hUb2tlbiA9IHJlc3VsdC5yZWZyZXNoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudG9rZW5FeHBpcnkgPSByZXN1bHQudG9rZW5FeHBpcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlckVtYWlsID0gcmVzdWx0LnVzZXJFbWFpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTaWduZWQgaW4gYXMgJHtyZXN1bHQudXNlckVtYWlsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpOyAvLyBSZWZyZXNoIHRoZSBzZXR0aW5ncyBVSVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgU2lnbi1pbiBmYWlsZWQ6ICR7KGVyciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLSBHb29nbGUgRHJpdmUgT3B0aW9ucyAtLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0dvb2dsZSBEcml2ZSBPcHRpb25zJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXJnZXQgRm9sZGVyIElEJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdPcHRpb25hbC4gSUQgb2YgdGhlIEdvb2dsZSBEcml2ZSBmb2xkZXIgd2hlcmUgbmV3IGRvY3MgYXJlIGNyZWF0ZWQuICcgK1xuICAgICAgICAgICAgICAgICdMZWF2ZSBibGFuayBmb3IgdGhlIHJvb3Qgb2YgTXkgRHJpdmUuICcgK1xuICAgICAgICAgICAgICAgICdGaW5kIHRoZSBJRCBpbiB0aGUgZm9sZGVyIFVSTDogZHJpdmUuZ29vZ2xlLmNvbS9kcml2ZS9mb2xkZXJzL1RISVNfUEFSVCcsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignMWEyYjNjNGQ1ZS4uLicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Rm9sZGVySWQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRGb2xkZXJJZCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gLS0tLSBTZXR1cCBJbnN0cnVjdGlvbnMgLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdTZXR1cCBJbnN0cnVjdGlvbnMnIH0pO1xuXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGV0YWlscycpO1xuICAgICAgICBkZXRhaWxzLmNyZWF0ZUVsKCdzdW1tYXJ5JywgeyB0ZXh0OiAnSG93IHRvIGNyZWF0ZSBHb29nbGUgQ2xvdWQgT0F1dGggY3JlZGVudGlhbHMnIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gZGV0YWlscy5jcmVhdGVFbCgnb2wnKTtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW1xuICAgICAgICAgICAgJ0dvIHRvIDxhIGhyZWY9XCJodHRwczovL2NvbnNvbGUuY2xvdWQuZ29vZ2xlLmNvbVwiPmNvbnNvbGUuY2xvdWQuZ29vZ2xlLmNvbTwvYT4nLFxuICAgICAgICAgICAgJ0NyZWF0ZSBhIG5ldyBwcm9qZWN0IChvciBzZWxlY3QgYW4gZXhpc3Rpbmcgb25lKScsXG4gICAgICAgICAgICAnTmF2aWdhdGUgdG8gPGI+QVBJcyAmIFNlcnZpY2VzIFx1MjE5MiBMaWJyYXJ5PC9iPicsXG4gICAgICAgICAgICAnU2VhcmNoIGZvciBhbmQgZW5hYmxlIHRoZSA8Yj5Hb29nbGUgRHJpdmUgQVBJPC9iPicsXG4gICAgICAgICAgICAnTmF2aWdhdGUgdG8gPGI+QVBJcyAmIFNlcnZpY2VzIFx1MjE5MiBDcmVkZW50aWFsczwvYj4nLFxuICAgICAgICAgICAgJ0NsaWNrIDxiPkNyZWF0ZSBDcmVkZW50aWFscyBcdTIxOTIgT0F1dGggY2xpZW50IElEPC9iPicsXG4gICAgICAgICAgICAnQ2hvb3NlIGFwcGxpY2F0aW9uIHR5cGU6IDxiPkRlc2t0b3AgYXBwPC9iPicsXG4gICAgICAgICAgICAnR2l2ZSBpdCBhIG5hbWUgKGUuZy4sIFwiT2JzaWRpYW4gUHVibGlzaFwiKScsXG4gICAgICAgICAgICAnQ2xpY2sgPGI+Q3JlYXRlPC9iPicsXG4gICAgICAgICAgICAnQ29weSB0aGUgPGI+Q2xpZW50IElEPC9iPiBhbmQgPGI+Q2xpZW50IFNlY3JldDwvYj4gaW50byB0aGUgZmllbGRzIGFib3ZlJyxcbiAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gY29uZmlndXJlIHRoZSA8Yj5PQXV0aCBjb25zZW50IHNjcmVlbjwvYj4gZmlyc3QgKGNob29zZSBcIkV4dGVybmFsXCIgdHlwZSwgYWRkIHlvdXJzZWxmIGFzIGEgdGVzdCB1c2VyKScsXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpID0gc3RlcHMuY3JlYXRlRWwoJ2xpJyk7XG4gICAgICAgICAgICBsaS5pbm5lckhUTUwgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlY3VyaXR5Tm90ZSA9IGRldGFpbHMuY3JlYXRlRWwoJ3AnKTtcbiAgICAgICAgc2VjdXJpdHlOb3RlLmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPGI+U2VjdXJpdHkgbm90ZTo8L2I+IFlvdXIgY3JlZGVudGlhbHMgYXJlIHN0b3JlZCBsb2NhbGx5IGluICcgK1xuICAgICAgICAgICAgJzxjb2RlPi5vYnNpZGlhbi9wbHVnaW5zL3B1Ymxpc2gtdG8tZ29vZ2xlLWRvY3MvZGF0YS5qc29uPC9jb2RlPi4gJyArXG4gICAgICAgICAgICAnSWYgeW91ciB2YXVsdCBzeW5jcyB2aWEgY2xvdWQgc3RvcmFnZSAoT25lRHJpdmUsIERyb3Bib3gsIGV0Yy4pLCAnICtcbiAgICAgICAgICAgICd0aGlzIGZpbGUgd2lsbCBiZSBzeW5jZWQgdG9vLiBUaGUgcGx1Z2luIG9ubHkgcmVxdWVzdHMgdGhlIG5hcnJvd2VzdCAnICtcbiAgICAgICAgICAgICdwb3NzaWJsZSBzY29wZSAoPGNvZGU+ZHJpdmUuZmlsZTwvY29kZT4pIHdoaWNoIGxpbWl0cyBhY2Nlc3MgdG8gZmlsZXMgJyArXG4gICAgICAgICAgICAnY3JlYXRlZCBieSB0aGlzIHBsdWdpbi4nO1xuICAgIH1cbn1cbiIsICIvLyBhdXRoLnRzIFx1MjAxNCBPQXV0aCAyLjAgd2l0aCBsb29wYmFjayBzZXJ2ZXIgKyBQS0NFIGZvciBHb29nbGUgQVBJc1xuLy9cbi8vIEZsb3c6IHBsdWdpbiBvcGVucyBicm93c2VyIFx1MjE5MiBHb29nbGUgY29uc2VudCBzY3JlZW4gKGFjY291bnQgY2hvb3NlcikgXHUyMTkyXG4vLyB1c2VyIGF1dGhvcml6ZXMgXHUyMTkyIHJlZGlyZWN0IHRvIGh0dHA6Ly8xMjcuMC4wLjE6PHBvcnQ+IFx1MjE5MiBwbHVnaW4gZXh0cmFjdHNcbi8vIGF1dGggY29kZSBcdTIxOTIgZXhjaGFuZ2VzIGZvciB0b2tlbnMgXHUyMTkyIHN0b3JlcyBpbiBwbHVnaW4gc2V0dGluZ3MuXG5cbmltcG9ydCB7IHJlcXVlc3RVcmwsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7XG4gICAgUGx1Z2luU2V0dGluZ3MsXG4gICAgR09PR0xFX0FVVEhfVVJMLFxuICAgIEdPT0dMRV9UT0tFTl9VUkwsXG4gICAgR09PR0xFX1VTRVJJTkZPX1VSTCxcbiAgICBTQ09QRVMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBOb2RlLmpzIG1vZHVsZXMgYXZhaWxhYmxlIGluIEVsZWN0cm9uXG5pbXBvcnQgKiBhcyBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8vIC0tLS0gUEtDRSBIZWxwZXJzIC0tLS1cblxuLyoqIEdlbmVyYXRlIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIGNvZGUgdmVyaWZpZXIgKDQzLTEyOCBjaGFycywgYmFzZTY0dXJsKSAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyg2NCk7XG4gICAgcmV0dXJuIGJ5dGVzXG4gICAgICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgICAucmVwbGFjZSgvPS9nLCAnJylcbiAgICAgICAgLnNsaWNlKDAsIDEyOCk7XG59XG5cbi8qKiBTSEEtMjU2IGhhc2ggb2YgdmVyaWZpZXIsIGJhc2U2NHVybC1lbmNvZGVkIChubyBwYWRkaW5nKSAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKHZlcmlmaWVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHZlcmlmaWVyKS5kaWdlc3QoKTtcbiAgICByZXR1cm4gaGFzaFxuICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpO1xufVxuXG4vKiogUmFuZG9tIHN0YXRlIHN0cmluZyBmb3IgQ1NSRiBwcm90ZWN0aW9uICovXG5mdW5jdGlvbiBnZW5lcmF0ZVN0YXRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpO1xufVxuXG4vLyAtLS0tIExvb3BiYWNrIFNlcnZlciAtLS0tXG5cbmludGVyZmFjZSBMb29wYmFja1Jlc3VsdCB7XG4gICAgcG9ydDogbnVtYmVyO1xuICAgIGNvZGVQcm9taXNlOiBQcm9taXNlPHN0cmluZz47XG4gICAgc2VydmVyOiBodHRwLlNlcnZlcjtcbn1cblxuLyoqXG4gKiBTcGluIHVwIGEgdGVtcG9yYXJ5IEhUVFAgc2VydmVyIG9uIDEyNy4wLjAuMSB3aXRoIGFuIE9TLWFzc2lnbmVkIHBvcnQuXG4gKiBXYWl0cyBmb3IgR29vZ2xlJ3MgT0F1dGggcmVkaXJlY3QsIGV4dHJhY3RzIHRoZSBhdXRob3JpemF0aW9uIGNvZGUsXG4gKiBzZW5kcyBhIHN1Y2Nlc3MgcGFnZSB0byB0aGUgYnJvd3NlciwgYW5kIHNodXRzIGRvd24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0TG9vcGJhY2tTZXJ2ZXIoZXhwZWN0ZWRTdGF0ZTogc3RyaW5nKTogUHJvbWlzZTxMb29wYmFja1Jlc3VsdD4ge1xuICAgIGxldCByZXNvbHZlQ29kZTogKGNvZGU6IHN0cmluZykgPT4gdm9pZDtcbiAgICBsZXQgcmVqZWN0Q29kZTogKGVycjogRXJyb3IpID0+IHZvaWQ7XG5cbiAgICBjb25zdCBjb2RlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlQ29kZSA9IHJlc29sdmU7XG4gICAgICAgIHJlamVjdENvZGUgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSB0aGUgY2FsbGJhY2sgVVJMXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCB8fCAnLycsIGBodHRwOi8vMTI3LjAuMC4xYCk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnY29kZScpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdzdGF0ZScpO1xuICAgICAgICBjb25zdCBlcnJvciA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdlcnJvcicpO1xuXG4gICAgICAgIC8vIEFsd2F5cyBzZW5kIGEgcmVzcG9uc2Ugc28gdGhlIGJyb3dzZXIgZG9lc24ndCBoYW5nXG4gICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7ICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sOyBjaGFyc2V0PXV0Zi04JyB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlcy5lbmQoYDxodG1sPjxib2R5PjxoMT5BdXRob3JpemF0aW9uIGZhaWxlZDwvaDE+XG4gICAgICAgICAgICAgICAgPHA+RXJyb3I6ICR7ZXJyb3J9PC9wPlxuICAgICAgICAgICAgICAgIDxwPllvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cuPC9wPjwvYm9keT48L2h0bWw+YCk7XG4gICAgICAgICAgICByZWplY3RDb2RlKG5ldyBFcnJvcihgT0F1dGggZXJyb3I6ICR7ZXJyb3J9YCkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb2RlIHx8IHN0YXRlICE9PSBleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgICAgICByZXMuZW5kKGA8aHRtbD48Ym9keT48aDE+QXV0aG9yaXphdGlvbiBmYWlsZWQ8L2gxPlxuICAgICAgICAgICAgICAgIDxwPkludmFsaWQgcmVzcG9uc2UgZnJvbSBHb29nbGUuIFBsZWFzZSB0cnkgYWdhaW4uPC9wPlxuICAgICAgICAgICAgICAgIDxwPllvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cuPC9wPjwvYm9keT48L2h0bWw+YCk7XG4gICAgICAgICAgICByZWplY3RDb2RlKG5ldyBFcnJvcignSW52YWxpZCBPQXV0aCBjYWxsYmFjazogbWlzc2luZyBjb2RlIG9yIHN0YXRlIG1pc21hdGNoJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLmVuZChgPGh0bWw+PGJvZHk+PGgxPkF1dGhvcml6YXRpb24gc3VjY2Vzc2Z1bCE8L2gxPlxuICAgICAgICAgICAgICAgIDxwPllvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cgYW5kIHJldHVybiB0byBPYnNpZGlhbi48L3A+PC9ib2R5PjwvaHRtbD5gKTtcbiAgICAgICAgICAgIHJlc29sdmVDb2RlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2h1dCBkb3duIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBicmllZiBkZWxheSAobGV0IHRoZSByZXNwb25zZSBmbHVzaClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gb24gZXBoZW1lcmFsIHBvcnQgb24gbG9vcGJhY2sgb25seSBcdTIwMTQgd2FpdCBmb3IgJ2xpc3RlbmluZycgZXZlbnRcbiAgICAvLyBiZWZvcmUgcmVhZGluZyB0aGUgYXNzaWduZWQgcG9ydFxuICAgIGNvbnN0IHBvcnQgPSBhd2FpdCBuZXcgUHJvbWlzZTxudW1iZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc2VydmVyLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHNlcnZlci5saXN0ZW4oMCwgJzEyNy4wLjAuMScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgYXNzaWduZWRQb3J0ID0gdHlwZW9mIGFkZHJlc3MgPT09ICdvYmplY3QnICYmIGFkZHJlc3MgPyBhZGRyZXNzLnBvcnQgOiAwO1xuICAgICAgICAgICAgcmVzb2x2ZShhc3NpZ25lZFBvcnQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRpbWVvdXQ6IHJlamVjdCBpZiBubyBjYWxsYmFjayB3aXRoaW4gMTIwIHNlY29uZHNcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICByZWplY3RDb2RlKG5ldyBFcnJvcignT0F1dGggdGltZW91dDogbm8gY2FsbGJhY2sgcmVjZWl2ZWQgd2l0aGluIDEyMCBzZWNvbmRzJykpO1xuICAgIH0sIDEyMDAwMCk7XG5cbiAgICAvLyBDbGVhciB0aW1lb3V0IG9uY2Ugd2UgZ2V0IHRoZSBjb2RlXG4gICAgY29kZVByb21pc2UuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCkpO1xuXG4gICAgcmV0dXJuIHsgcG9ydCwgY29kZVByb21pc2UsIHNlcnZlciB9O1xufVxuXG4vLyAtLS0tIFRva2VuIEV4Y2hhbmdlIC0tLS1cblxuaW50ZXJmYWNlIFRva2VuUmVzcG9uc2Uge1xuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XG4gICAgdG9rZW5FeHBpcnk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBFeGNoYW5nZSBhbiBhdXRob3JpemF0aW9uIGNvZGUgZm9yIGFjY2VzcyArIHJlZnJlc2ggdG9rZW5zLlxuICovXG5hc3luYyBmdW5jdGlvbiBleGNoYW5nZUNvZGVGb3JUb2tlbnMoXG4gICAgY29kZTogc3RyaW5nLFxuICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgY2xpZW50U2VjcmV0OiBzdHJpbmcsXG4gICAgcmVkaXJlY3RVcmk6IHN0cmluZyxcbiAgICBjb2RlVmVyaWZpZXI6IHN0cmluZyxcbik6IFByb21pc2U8VG9rZW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogY2xpZW50U2VjcmV0LFxuICAgICAgICByZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpLFxuICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgIH0pLnRvU3RyaW5nKCk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICB1cmw6IEdPT0dMRV9UT0tFTl9VUkwsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICBib2R5LFxuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmpzb247XG4gICAgaWYgKCFkYXRhLmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuIGV4Y2hhbmdlIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhY2Nlc3NUb2tlbjogZGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hUb2tlbjogZGF0YS5yZWZyZXNoX3Rva2VuIHx8ICcnLFxuICAgICAgICB0b2tlbkV4cGlyeTogRGF0ZS5ub3coKSArIChkYXRhLmV4cGlyZXNfaW4gfHwgMzYwMCkgKiAxMDAwLFxuICAgIH07XG59XG5cbi8qKlxuICogRmV0Y2ggdGhlIGF1dGhlbnRpY2F0ZWQgdXNlcidzIGVtYWlsIGFkZHJlc3MgZnJvbSBHb29nbGUncyB1c2VyaW5mbyBlbmRwb2ludC5cbiAqIE5vbi1mYXRhbDogcmV0dXJucyAndW5rbm93bicgaWYgdGhlIHNjb3BlIHdhc24ndCBncmFudGVkIG9yIHRoZSBjYWxsIGZhaWxzLlxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFVzZXJFbWFpbChhY2Nlc3NUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBHT09HTEVfVVNFUklORk9fVVJMLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24uZW1haWwgfHwgJ2F1dGhlbnRpY2F0ZWQnO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBUaGUgZW1haWwvdXNlcmluZm8gc2NvcGUgd2Fzbid0IHJlcXVlc3RlZCBcdTIwMTQgdGhhdCdzIGZpbmUsXG4gICAgICAgIC8vIHdlIG9ubHkgbmVlZCBkcml2ZS5maWxlIHNjb3BlIGZvciBhY3R1YWwgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgcmV0dXJuICdhdXRoZW50aWNhdGVkJztcbiAgICB9XG59XG5cbi8vIC0tLS0gUHVibGljIEFQSSAtLS0tXG5cbi8qKlxuICogUnVuIHRoZSBmdWxsIE9BdXRoIDIuMCBhdXRob3JpemF0aW9uIGZsb3cuXG4gKiBPcGVucyB0aGUgYnJvd3NlciB3aXRoIEdvb2dsZSdzIGFjY291bnQgY2hvb3Nlciwgd2FpdHMgZm9yIHRoZSBjYWxsYmFjayxcbiAqIGV4Y2hhbmdlcyB0aGUgY29kZSBmb3IgdG9rZW5zLCBhbmQgZmV0Y2hlcyB0aGUgdXNlcidzIGVtYWlsLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlKHNldHRpbmdzOiBQbHVnaW5TZXR0aW5ncyk6IFByb21pc2U8e1xuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XG4gICAgdG9rZW5FeHBpcnk6IG51bWJlcjtcbiAgICB1c2VyRW1haWw6IHN0cmluZztcbn0+IHtcbiAgICBpZiAoIXNldHRpbmdzLmNsaWVudElkIHx8ICFzZXR0aW5ncy5jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29uZmlndXJlIHlvdXIgR29vZ2xlIENsaWVudCBJRCBhbmQgQ2xpZW50IFNlY3JldCBpbiBwbHVnaW4gc2V0dGluZ3MuJyk7XG4gICAgfVxuXG4gICAgLy8gUEtDRVxuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlQ29kZVZlcmlmaWVyKCk7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGdlbmVyYXRlQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IHN0YXRlID0gZ2VuZXJhdGVTdGF0ZSgpO1xuXG4gICAgLy8gU3RhcnQgbG9vcGJhY2sgc2VydmVyXG4gICAgY29uc3QgeyBwb3J0LCBjb2RlUHJvbWlzZSwgc2VydmVyIH0gPSBhd2FpdCBzdGFydExvb3BiYWNrU2VydmVyKHN0YXRlKTtcbiAgICBjb25zdCByZWRpcmVjdFVyaSA9IGBodHRwOi8vMTI3LjAuMC4xOiR7cG9ydH1gO1xuXG4gICAgLy8gQnVpbGQgYXV0aG9yaXphdGlvbiBVUkxcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY2xpZW50X2lkOiBzZXR0aW5ncy5jbGllbnRJZCxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaSxcbiAgICAgICAgcmVzcG9uc2VfdHlwZTogJ2NvZGUnLFxuICAgICAgICBzY29wZTogU0NPUEVTLFxuICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiAnUzI1NicsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhY2Nlc3NfdHlwZTogJ29mZmxpbmUnLFxuICAgICAgICBwcm9tcHQ6ICdzZWxlY3RfYWNjb3VudCBjb25zZW50JywgIC8vIGZvcmNlIGFjY291bnQgY2hvb3NlciArIGFsd2F5cyBnZXQgcmVmcmVzaCB0b2tlblxuICAgIH0pO1xuXG4gICAgLy8gSWYgd2Uga25vdyB0aGUgdXNlcidzIGVtYWlsLCBoaW50IGl0IChwcmUtc2VsZWN0cyBpbiBhY2NvdW50IGNob29zZXIpXG4gICAgaWYgKHNldHRpbmdzLnVzZXJFbWFpbCkge1xuICAgICAgICBwYXJhbXMuc2V0KCdsb2dpbl9oaW50Jywgc2V0dGluZ3MudXNlckVtYWlsKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRoVXJsID0gYCR7R09PR0xFX0FVVEhfVVJMfT8ke3BhcmFtcy50b1N0cmluZygpfWA7XG5cbiAgICAvLyBPcGVuIGluIGRlZmF1bHQgYnJvd3NlclxuICAgIHdpbmRvdy5vcGVuKGF1dGhVcmwpO1xuICAgIG5ldyBOb3RpY2UoYE9BdXRoOiB3YWl0aW5nIGZvciBjYWxsYmFjayBvbiBwb3J0ICR7cG9ydH0uLi5gKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjYWxsYmFja1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgY29kZVByb21pc2U7XG4gICAgICAgIG5ldyBOb3RpY2UoJ09BdXRoOiByZWNlaXZlZCBhdXRoIGNvZGUsIGV4Y2hhbmdpbmcgZm9yIHRva2Vucy4uLicpO1xuICAgICAgICBjb25zb2xlLmxvZygnT0F1dGg6IGF1dGggY29kZSByZWNlaXZlZCwgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKTtcblxuICAgICAgICAvLyBFeGNoYW5nZSBjb2RlIGZvciB0b2tlbnNcbiAgICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgZXhjaGFuZ2VDb2RlRm9yVG9rZW5zKFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIHNldHRpbmdzLmNsaWVudElkLFxuICAgICAgICAgICAgc2V0dGluZ3MuY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICAgICAgICBjb2RlVmVyaWZpZXIsXG4gICAgICAgICk7XG4gICAgICAgIG5ldyBOb3RpY2UoJ09BdXRoOiB0b2tlbnMgcmVjZWl2ZWQsIGZldGNoaW5nIHVzZXIgaW5mby4uLicpO1xuICAgICAgICBjb25zb2xlLmxvZygnT0F1dGg6IGdvdCBhY2Nlc3MgdG9rZW4sIGhhcyByZWZyZXNoOicsICEhdG9rZW5zLnJlZnJlc2hUb2tlbik7XG5cbiAgICAgICAgLy8gRmV0Y2ggdXNlciBlbWFpbFxuICAgICAgICBjb25zdCB1c2VyRW1haWwgPSBhd2FpdCBmZXRjaFVzZXJFbWFpbCh0b2tlbnMuYWNjZXNzVG9rZW4pO1xuICAgICAgICBuZXcgTm90aWNlKGBPQXV0aDogc2lnbmVkIGluIGFzICR7dXNlckVtYWlsfWApO1xuXG4gICAgICAgIHJldHVybiB7IC4uLnRva2VucywgdXNlckVtYWlsIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBzZXJ2ZXIgaXMgY2xvc2VkIG9uIGVycm9yXG4gICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdPQXV0aCBlcnJvcjonLCBlcnIpO1xuICAgICAgICBuZXcgTm90aWNlKGBPQXV0aCBlcnJvcjogJHsoZXJyIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlZnJlc2ggYW4gZXhwaXJlZCBhY2Nlc3MgdG9rZW4gdXNpbmcgdGhlIHN0b3JlZCByZWZyZXNoIHRva2VuLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEFjY2Vzc1Rva2VuKHNldHRpbmdzOiBQbHVnaW5TZXR0aW5ncyk6IFByb21pc2U8e1xuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gICAgdG9rZW5FeHBpcnk6IG51bWJlcjtcbn0+IHtcbiAgICBpZiAoIXNldHRpbmdzLnJlZnJlc2hUb2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlLiBQbGVhc2Ugc2lnbiBpbiBhZ2Fpbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGNsaWVudF9pZDogc2V0dGluZ3MuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHNldHRpbmdzLmNsaWVudFNlY3JldCxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogc2V0dGluZ3MucmVmcmVzaFRva2VuLFxuICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgfSkudG9TdHJpbmcoKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgIHVybDogR09PR0xFX1RPS0VOX1VSTCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXG4gICAgICAgIGJvZHksXG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuanNvbjtcbiAgICBpZiAoIWRhdGEuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gcmVmcmVzaCBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzVG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgICB0b2tlbkV4cGlyeTogRGF0ZS5ub3coKSArIChkYXRhLmV4cGlyZXNfaW4gfHwgMzYwMCkgKiAxMDAwLFxuICAgIH07XG59XG5cbi8qKlxuICogR2V0IGEgdmFsaWQgYWNjZXNzIHRva2VuLCByZWZyZXNoaW5nIG9yIHJlLWF1dGhlbnRpY2F0aW5nIGFzIG5lZWRlZC5cbiAqIFVwZGF0ZXMgc2V0dGluZ3MgaW4gcGxhY2UgYW5kIGNhbGxzIHNhdmVGbiB0byBwZXJzaXN0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmFsaWRUb2tlbihcbiAgICBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3MsXG4gICAgc2F2ZUZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBObyByZWZyZXNoIHRva2VuIGF0IGFsbCBcdTIxOTIgbmVlZCBmdWxsIGF1dGhcbiAgICBpZiAoIXNldHRpbmdzLnJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGUoc2V0dGluZ3MpO1xuICAgICAgICBzZXR0aW5ncy5hY2Nlc3NUb2tlbiA9IHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgc2V0dGluZ3MucmVmcmVzaFRva2VuID0gcmVzdWx0LnJlZnJlc2hUb2tlbjtcbiAgICAgICAgc2V0dGluZ3MudG9rZW5FeHBpcnkgPSByZXN1bHQudG9rZW5FeHBpcnk7XG4gICAgICAgIHNldHRpbmdzLnVzZXJFbWFpbCA9IHJlc3VsdC51c2VyRW1haWw7XG4gICAgICAgIGF3YWl0IHNhdmVGbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIC8vIFRva2VuIHN0aWxsIHZhbGlkICh3aXRoIDYwcyBidWZmZXIpXG4gICAgaWYgKHNldHRpbmdzLmFjY2Vzc1Rva2VuICYmIERhdGUubm93KCkgPCBzZXR0aW5ncy50b2tlbkV4cGlyeSAtIDYwMDAwKSB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5hY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICAvLyBUb2tlbiBleHBpcmVkIFx1MjE5MiByZWZyZXNoXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaEFjY2Vzc1Rva2VuKHNldHRpbmdzKTtcbiAgICAgICAgc2V0dGluZ3MuYWNjZXNzVG9rZW4gPSByZXN1bHQuYWNjZXNzVG9rZW47XG4gICAgICAgIHNldHRpbmdzLnRva2VuRXhwaXJ5ID0gcmVzdWx0LnRva2VuRXhwaXJ5O1xuICAgICAgICBhd2FpdCBzYXZlRm4oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gUmVmcmVzaCBmYWlsZWQgKHRva2VuIHJldm9rZWQ/KSBcdTIxOTIgZnVsbCByZS1hdXRoXG4gICAgICAgIG5ldyBOb3RpY2UoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkLiBQbGVhc2Ugc2lnbiBpbiBhZ2Fpbi4nKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlKHNldHRpbmdzKTtcbiAgICAgICAgc2V0dGluZ3MuYWNjZXNzVG9rZW4gPSByZXN1bHQuYWNjZXNzVG9rZW47XG4gICAgICAgIHNldHRpbmdzLnJlZnJlc2hUb2tlbiA9IHJlc3VsdC5yZWZyZXNoVG9rZW47XG4gICAgICAgIHNldHRpbmdzLnRva2VuRXhwaXJ5ID0gcmVzdWx0LnRva2VuRXhwaXJ5O1xuICAgICAgICBzZXR0aW5ncy51c2VyRW1haWwgPSByZXN1bHQudXNlckVtYWlsO1xuICAgICAgICBhd2FpdCBzYXZlRm4oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICB9XG59XG4iLCAiLy8gcHVibGlzaGVyLnRzIFx1MjAxNCBPcmNoZXN0cmF0b3IgZm9yIHRoZSBwdWJsaXNoIHdvcmtmbG93XG4vL1xuLy8gVGllcyB0b2dldGhlcjogY29udmVydGVyIChtYXJrZG93blx1MjE5MkhUTUwpLCBnb29nbGUtYXBpICh1cGxvYWQpLFxuLy8gYXV0aCAodG9rZW5zKSwgYW5kIGZyb250bWF0dGVyIChzdG9yZSBkb2MgVVJMKS5cbi8vIFByZXNlbnRzIHRoZSB1c2VyIHdpdGggYSBjaG9pY2UgbW9kYWwgd2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBkb2MuXG5cbmltcG9ydCB7XG4gICAgQXBwLFxuICAgIE1vZGFsLFxuICAgIE5vdGljZSxcbiAgICByZXF1ZXN0VXJsLFxuICAgIFNldHRpbmcsXG4gICAgVEZpbGUsXG59IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIFB1Ymxpc2hUb0dvb2dsZURvY3NQbHVnaW4gZnJvbSAnLi9tYWluJztcbmltcG9ydCB7IGNvbnZlcnROb3RlVG9IdG1sIH0gZnJvbSAnLi9jb252ZXJ0ZXInO1xuaW1wb3J0IHtcbiAgICBjcmVhdGVHb29nbGVEb2MsXG4gICAgZGVsZXRlR29vZ2xlRG9jLFxuICAgIHVwbG9hZEltYWdlVG9Ecml2ZSxcbiAgICBleHRyYWN0RG9jSWQsXG59IGZyb20gJy4vZ29vZ2xlLWFwaSc7XG5pbXBvcnQgeyBnZXRWYWxpZFRva2VuIH0gZnJvbSAnLi9hdXRoJztcblxuLy8gLS0tLSBDaG9pY2UgTW9kYWwgLS0tLVxuXG50eXBlIFVwZGF0ZUNob2ljZSA9ICd1cGRhdGUnIHwgJ25ldycgfCBudWxsO1xuXG4vKipcbiAqIE1vZGFsIGRpYWxvZyB0aGF0IGFza3MgdGhlIHVzZXIgd2hldGhlciB0byB1cGRhdGUgdGhlIGV4aXN0aW5nXG4gKiBHb29nbGUgRG9jIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKi9cbmNsYXNzIFVwZGF0ZUNob2ljZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHByaXZhdGUgcmVzb2x2ZUZuOiAodmFsdWU6IFVwZGF0ZUNob2ljZSkgPT4gdm9pZDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCByZXNvbHZlRm46ICh2YWx1ZTogVXBkYXRlQ2hvaWNlKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUZuID0gcmVzb2x2ZUZuO1xuICAgIH1cblxuICAgIG9uT3BlbigpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygncHVibGlzaC1nZG9jcy1tb2RhbCcpO1xuXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdQdWJsaXNoIHRvIEdvb2dsZSBEb2NzJyB9KTtcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgdGV4dDogJ1RoaXMgbm90ZSBhbHJlYWR5IGhhcyBhIGxpbmtlZCBHb29nbGUgRG9jLiBXaGF0IHdvdWxkIHlvdSBsaWtlIHRvIGRvPycsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoJ21vZGFsLWJ1dHRvbi1jb250YWluZXInKTtcblxuICAgICAgICAvLyBVcGRhdGUgYnV0dG9uIChwcmltYXJ5IGFjdGlvbilcbiAgICAgICAgY29uc3QgdXBkYXRlQnRuID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdVcGRhdGUgZXhpc3RpbmcnIH0pO1xuICAgICAgICB1cGRhdGVCdG4uYWRkQ2xhc3MoJ21vZC1jdGEnKTtcbiAgICAgICAgdXBkYXRlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRm4oJ3VwZGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IGJ1dHRvblxuICAgICAgICBjb25zdCBuZXdCdG4gPSBidXR0b25Db250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0NyZWF0ZSBuZXcnIH0pO1xuICAgICAgICBuZXdCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGbignbmV3Jyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENhbmNlbCBidXR0b25cbiAgICAgICAgY29uc3QgY2FuY2VsQnRuID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDYW5jZWwnIH0pO1xuICAgICAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGbihudWxsKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG5cbi8qKiBTaG93IHRoZSB1cGRhdGUgY2hvaWNlIG1vZGFsIGFuZCByZXR1cm4gdGhlIHVzZXIncyBzZWxlY3Rpb24gKi9cbmZ1bmN0aW9uIHNob3dVcGRhdGVDaG9pY2VNb2RhbChhcHA6IEFwcCk6IFByb21pc2U8VXBkYXRlQ2hvaWNlPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIG5ldyBVcGRhdGVDaG9pY2VNb2RhbChhcHAsIHJlc29sdmUpLm9wZW4oKTtcbiAgICB9KTtcbn1cblxuLy8gLS0tLSBNYWluIFB1Ymxpc2ggRnVuY3Rpb24gLS0tLVxuXG4vKipcbiAqIFB1Ymxpc2ggYW4gT2JzaWRpYW4gbm90ZSB0byBHb29nbGUgRG9jcy5cbiAqXG4gKiAxLiBWYWxpZGF0ZXMgY3JlZGVudGlhbHNcbiAqIDIuIEdldHMgYSB2YWxpZCBPQXV0aCB0b2tlbiAobWF5IHRyaWdnZXIgYnJvd3NlciBhdXRoIGZsb3cpXG4gKiAzLiBDaGVja3MgZnJvbnRtYXR0ZXIgZm9yIGV4aXN0aW5nIGdvb2dsZV9kb2MgVVJMXG4gKiA0LiBJZiBleGlzdHMsIGFza3MgdXNlcjogdXBkYXRlIG9yIGNyZWF0ZSBuZXc/XG4gKiA1LiBDb252ZXJ0cyBtYXJrZG93biBcdTIxOTIgSFRNTFxuICogNi4gQ3JlYXRlcyBuZXcgR29vZ2xlIERvYyB2aWEgRHJpdmUgQVBJXG4gKiA3LiBJZiB1cGRhdGluZywgZGVsZXRlcyB0aGUgb2xkIGRvY1xuICogOC4gV3JpdGVzIHRoZSBuZXcgZG9jIFVSTCB0byBmcm9udG1hdHRlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHVibGlzaE5vdGUoXG4gICAgcGx1Z2luOiBQdWJsaXNoVG9Hb29nbGVEb2NzUGx1Z2luLFxuICAgIGZpbGU6IFRGaWxlLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gMS4gVmFsaWRhdGUgY3JlZGVudGlhbHNcbiAgICBpZiAoIXBsdWdpbi5zZXR0aW5ncy5jbGllbnRJZCB8fCAhcGx1Z2luLnNldHRpbmdzLmNsaWVudFNlY3JldCkge1xuICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2UgY29uZmlndXJlIEdvb2dsZSBBUEkgY3JlZGVudGlhbHMgaW4gdGhlIHBsdWdpbiBzZXR0aW5ncyBmaXJzdC4nKTtcbiAgICAgICAgLy8gT3BlbiBzZXR0aW5nc1xuICAgICAgICBjb25zdCBzZXR0aW5nVGFiID0gKHBsdWdpbi5hcHAgYXMgYW55KS5zZXR0aW5nO1xuICAgICAgICBpZiAoc2V0dGluZ1RhYikge1xuICAgICAgICAgICAgc2V0dGluZ1RhYi5vcGVuKCk7XG4gICAgICAgICAgICBzZXR0aW5nVGFiLm9wZW5UYWJCeUlkKCdwdWJsaXNoLXRvLWdvb2dsZS1kb2NzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDIuIEdldCB2YWxpZCBhY2Nlc3MgdG9rZW5cbiAgICBsZXQgdG9rZW46IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgICB0b2tlbiA9IGF3YWl0IGdldFZhbGlkVG9rZW4ocGx1Z2luLnNldHRpbmdzLCAoKSA9PiBwbHVnaW4uc2F2ZVNldHRpbmdzKCkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBuZXcgTm90aWNlKGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7KGVyciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDMuIENoZWNrIGZyb250bWF0dGVyIGZvciBleGlzdGluZyBnb29nbGVfZG9jIFVSTFxuICAgIGxldCBleGlzdGluZ1VybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgY2FjaGUgPSBwbHVnaW4uYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgIGlmIChjYWNoZT8uZnJvbnRtYXR0ZXI/Lmdvb2dsZV9kb2MpIHtcbiAgICAgICAgZXhpc3RpbmdVcmwgPSBjYWNoZS5mcm9udG1hdHRlci5nb29nbGVfZG9jO1xuICAgIH1cblxuICAgIC8vIDQuIElmIGV4aXN0aW5nIGRvYywgc2hvdyBjaG9pY2UgbW9kYWxcbiAgICBsZXQgYWN0aW9uOiAndXBkYXRlJyB8ICduZXcnID0gJ25ldyc7XG4gICAgaWYgKGV4aXN0aW5nVXJsKSB7XG4gICAgICAgIGNvbnN0IGNob2ljZSA9IGF3YWl0IHNob3dVcGRhdGVDaG9pY2VNb2RhbChwbHVnaW4uYXBwKTtcbiAgICAgICAgaWYgKGNob2ljZSA9PT0gbnVsbCkgcmV0dXJuOyAvLyBVc2VyIGNhbmNlbGxlZFxuICAgICAgICBhY3Rpb24gPSBjaG9pY2U7XG4gICAgfVxuXG4gICAgLy8gNS4gU2hvdyBwcm9ncmVzc1xuICAgIGNvbnN0IHByb2dyZXNzTm90aWNlID0gbmV3IE5vdGljZSgnUHVibGlzaGluZyB0byBHb29nbGUgRG9jcy4uLicsIDApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gNi4gQ29udmVydCBub3RlIHRvIEhUTUxcbiAgICAgICAgY29uc3QgdXBsb2FkSW1hZ2UgPSBhc3luYyAoZGF0YTogQXJyYXlCdWZmZXIsIG5hbWU6IHN0cmluZywgbWltZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRJbWFnZVRvRHJpdmUoXG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWUsXG4gICAgICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLmRlZmF1bHRGb2xkZXJJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGh0bWwgPSBhd2FpdCBjb252ZXJ0Tm90ZVRvSHRtbChwbHVnaW4uYXBwLCBmaWxlLCB1cGxvYWRJbWFnZSk7XG5cbiAgICAgICAgLy8gNy4gQ3JlYXRlIG5ldyBHb29nbGUgRG9jXG4gICAgICAgIGNvbnN0IGRvY05hbWUgPSBmaWxlLmJhc2VuYW1lO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVHb29nbGVEb2MoXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGRvY05hbWUsXG4gICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLmRlZmF1bHRGb2xkZXJJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gOC4gSWYgdXBkYXRpbmcsIG1vdmUgb2xkIGRvYyB0byB0cmFzaCAobm90IHBlcm1hbmVudCBkZWxldGUpLlxuICAgICAgICAvLyAgICBVc2VyIGNhbiByZWNvdmVyIGZyb20gR29vZ2xlIERyaXZlIHRyYXNoIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3VwZGF0ZScgJiYgZXhpc3RpbmdVcmwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZElkID0gZXh0cmFjdERvY0lkKGV4aXN0aW5nVXJsKTtcbiAgICAgICAgICAgIGlmIChvbGRJZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdHJhc2ggaW5zdGVhZCBvZiBwZXJtYW5lbnQgZGVsZXRlXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZHJpdmUvdjMvZmlsZXMvJHtvbGRJZH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRyYXNoZWQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB0cmFzaCBvbGQgR29vZ2xlIERvYzonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb24tZmF0YWw6IG9sZCBkb2Mgc3RheXMsIG5ldyBkb2MgaXMgYWxyZWFkeSBjcmVhdGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOS4gV3JpdGUgdGhlIG5ldyBHb29nbGUgRG9jIFVSTCB0byBmcm9udG1hdHRlclxuICAgICAgICBhd2FpdCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZm0pID0+IHtcbiAgICAgICAgICAgIGZtLmdvb2dsZV9kb2MgPSByZXN1bHQud2ViVmlld0xpbms7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIDEwLiBTdWNjZXNzIVxuICAgICAgICBwcm9ncmVzc05vdGljZS5oaWRlKCk7XG4gICAgICAgIG5ldyBOb3RpY2UoYFB1Ymxpc2hlZCB0byBHb29nbGUgRG9jcyFcXG4ke3Jlc3VsdC53ZWJWaWV3TGlua31gLCAxMDAwMCk7XG5cbiAgICAgICAgLy8gT3BlbiB0aGUgbmV3IGRvYyBpbiB0aGUgYnJvd3NlclxuICAgICAgICB3aW5kb3cub3BlbihyZXN1bHQud2ViVmlld0xpbmspO1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHByb2dyZXNzTm90aWNlLmhpZGUoKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGF1dGggZXJyb3IgKDQwMS80MDMpIFx1MjAxNCByZXRyeSBvbmNlIHdpdGggZnJlc2ggdG9rZW5cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gKGVyciBhcyB7IHN0YXR1cz86IG51bWJlciB9KS5zdGF0dXM7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMSB8fCBzdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnQXV0aCB0b2tlbiBleHBpcmVkLiBSZWZyZXNoaW5nIGFuZCByZXRyeWluZy4uLicpO1xuICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLmFjY2Vzc1Rva2VuID0gJyc7XG4gICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3MudG9rZW5FeHBpcnkgPSAwO1xuICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAvLyBSZXRyeSBvbmNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hOb3RlKHBsdWdpbiwgZmlsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChyZXRyeUVycikge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFB1Ymxpc2ggZmFpbGVkIGFmdGVyIHJldHJ5OiAkeyhyZXRyeUVyciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBOb3RpY2UoYFB1Ymxpc2ggZmFpbGVkOiAkeyhlcnIgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1B1Ymxpc2ggdG8gR29vZ2xlIERvY3MgZXJyb3I6JywgZXJyKTtcbiAgICB9XG59XG4iLCAiLy8gY29udmVydGVyLnRzIFx1MjAxNCBNYXJrZG93bi10by1IVE1MIGNvbnZlcnNpb24gcGlwZWxpbmVcbi8vXG4vLyBQaXBlbGluZTogcmF3IG1hcmtkb3duIFx1MjE5MiBzdHJpcCBmcm9udG1hdHRlciBcdTIxOTIgcHJvdGVjdCBjb2RlIGJsb2NrcyBcdTIxOTJcbi8vICAgICAgICAgICBleHRyYWN0IExhVGVYIFx1MjE5MiBleHRyYWN0IGltYWdlcyBcdTIxOTIgcmVzdG9yZSBjb2RlIGJsb2NrcyBcdTIxOTJcbi8vICAgICAgICAgICByZW5kZXIgdmlhIE9ic2lkaWFuIFx1MjE5MiByZXN0b3JlIExhVGVYIFx1MjE5MiB1cGxvYWQgJiByZXN0b3JlIGltYWdlcyBcdTIxOTJcbi8vICAgICAgICAgICBjbGVhbiBIVE1MIFx1MjE5MiB3cmFwIGluIGRvY3VtZW50XG4vL1xuLy8gV2UgcHJlLWV4dHJhY3QgTGFUZVggYW5kIGltYWdlcyBmcm9tIHRoZSByYXcgbWFya2Rvd24gQkVGT1JFIHJlbmRlcmluZy5cbi8vIFRoaXMgYXZvaWRzIHR3byBmdW5kYW1lbnRhbCBwcm9ibGVtcyB3aXRoIHBvc3QtcmVuZGVyIGV4dHJhY3Rpb246XG4vLyAgIDEuIE1hdGhKYXggQ0hUTUwgb3V0cHV0IGRvZXNuJ3QgZXhwb3NlIG9yaWdpbmFsIFRlWCBzb3VyY2Vcbi8vICAgMi4gT2JzaWRpYW4gcmVuZGVycyBpbWFnZXMgd2l0aCBhYnNvbHV0ZSBhcHA6Ly8gcGF0aHMgKyBjYWNoZS1idXN0aW5nXG4vLyAgICAgIHF1ZXJ5IHN0cmluZ3MgdGhhdCBjYW4ndCBiZSByZXNvbHZlZCBiYWNrIHRvIHZhdWx0IGZpbGVzXG5cbmltcG9ydCB7XG4gICAgQXBwLFxuICAgIENvbXBvbmVudCxcbiAgICBNYXJrZG93blJlbmRlcmVyLFxuICAgIFRGaWxlLFxufSBmcm9tICdvYnNpZGlhbic7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbnRlcmZhY2UgRXh0cmFjdGlvbiB7XG4gICAgcGxhY2Vob2xkZXI6IHN0cmluZztcbiAgICBvcmlnaW5hbDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTWF0aEV4dHJhY3Rpb24gZXh0ZW5kcyBFeHRyYWN0aW9uIHtcbiAgICBpc0Rpc3BsYXk6IGJvb2xlYW47XG4gICAgbGF0ZXg6IHN0cmluZzsgLy8gY29udGVudCB3aXRob3V0ICQgZGVsaW1pdGVyc1xufVxuXG5pbnRlcmZhY2UgSW1hZ2VFeHRyYWN0aW9uIGV4dGVuZHMgRXh0cmFjdGlvbiB7XG4gICAgdmF1bHRQYXRoOiBzdHJpbmc7XG4gICAgYWx0OiBzdHJpbmc7XG4gICAgd2lkdGg6IHN0cmluZyB8IG51bGw7XG4gICAgaXNTdmc6IGJvb2xlYW47XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU1RFUCAxOiBTdHJpcCBZQU1MIEZyb250bWF0dGVyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaXBGcm9udG1hdHRlcihtYXJrZG93bjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBtYXRjaCA9IG1hcmtkb3duLm1hdGNoKC9eLS0tXFxyP1xcbltcXHNcXFNdKj9cXHI/XFxuLS0tXFxyP1xcbj8vKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXJrZG93bi5zbGljZShtYXRjaFswXS5sZW5ndGgpIDogbWFya2Rvd247XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU1RFUCAyOiBFeHRyYWN0IGNvZGUgYmxvY2tzIChwcm90ZWN0IGZyb20gbWF0aC9pbWFnZSByZWdleClcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBleHRyYWN0Q29kZUJsb2NrcyhtYXJrZG93bjogc3RyaW5nKTogeyBjbGVhbmVkOiBzdHJpbmc7IGJsb2NrczogRXh0cmFjdGlvbltdIH0ge1xuICAgIGNvbnN0IGJsb2NrczogRXh0cmFjdGlvbltdID0gW107XG5cbiAgICAvLyBGZW5jZWQgY29kZSBibG9ja3M6IGBgYC4uLmBgYFxuICAgIGxldCBjbGVhbmVkID0gbWFya2Rvd24ucmVwbGFjZSgvYGBgW1xcc1xcU10qP2BgYC9nLCAobWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgR0RPQ1NfQ0Ike2Jsb2Nrcy5sZW5ndGh9YDtcbiAgICAgICAgYmxvY2tzLnB1c2goeyBwbGFjZWhvbGRlciwgb3JpZ2luYWw6IG1hdGNoIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBJbmxpbmUgY29kZTogYC4uLmAgKHNpbmdsZSBiYWNrdGljaywgbm90IGVtcHR5KVxuICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoL2BbXmBcXG5dK2AvZywgKG1hdGNoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYEdET0NTX0NJJHtibG9ja3MubGVuZ3RofWA7XG4gICAgICAgIGJsb2Nrcy5wdXNoKHsgcGxhY2Vob2xkZXIsIG9yaWdpbmFsOiBtYXRjaCB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY2xlYW5lZCwgYmxvY2tzIH07XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVFeHRyYWN0aW9ucyh0ZXh0OiBzdHJpbmcsIGV4dHJhY3Rpb25zOiBFeHRyYWN0aW9uW10pOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSB0ZXh0O1xuICAgIC8vIFJlc3RvcmUgaW4gcmV2ZXJzZSBvcmRlciBmb3Igc2FmZXR5IHdpdGggbmVzdGVkIHBsYWNlaG9sZGVyc1xuICAgIGZvciAobGV0IGkgPSBleHRyYWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3BsaXQoZXh0cmFjdGlvbnNbaV0ucGxhY2Vob2xkZXIpLmpvaW4oZXh0cmFjdGlvbnNbaV0ub3JpZ2luYWwpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNURVAgMzogRXh0cmFjdCBMYVRlWCBtYXRoXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gZXh0cmFjdE1hdGgobWFya2Rvd246IHN0cmluZyk6IHsgY2xlYW5lZDogc3RyaW5nOyBtYXRoOiBNYXRoRXh0cmFjdGlvbltdIH0ge1xuICAgIGNvbnN0IG1hdGg6IE1hdGhFeHRyYWN0aW9uW10gPSBbXTtcblxuICAgIC8vIERpc3BsYXkgbWF0aDogJCQuLi4kJCAoY2FuIHNwYW4gbXVsdGlwbGUgbGluZXMpXG4gICAgbGV0IGNsZWFuZWQgPSBtYXJrZG93bi5yZXBsYWNlKC9cXCRcXCQoW1xcc1xcU10rPylcXCRcXCQvZywgKG1hdGNoLCBsYXRleCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBHRE9DU19NRCR7bWF0aC5sZW5ndGh9YDtcbiAgICAgICAgbWF0aC5wdXNoKHsgcGxhY2Vob2xkZXIsIG9yaWdpbmFsOiBtYXRjaCwgaXNEaXNwbGF5OiB0cnVlLCBsYXRleDogbGF0ZXgudHJpbSgpIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBJbmxpbmUgbWF0aDogJC4uLiQgKHNpbmdsZSBsaW5lLCBub3QgcHJlY2VkZWQvZm9sbG93ZWQgYnkgJClcbiAgICAvLyBSZXF1aXJlcyBub24tc3BhY2UgYWZ0ZXIgb3BlbmluZyAkIGFuZCBiZWZvcmUgY2xvc2luZyAkIHRvIGF2b2lkXG4gICAgLy8gZmFsc2UgbWF0Y2hlcyBvbiBjdXJyZW5jeSBsaWtlIFwiY29zdHMgJDUgb3IgJDEwXCJcbiAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC8oPzwhXFwkKVxcJCg/IVxcJHxcXHMpKFteJFxcbl0rPykoPzwhXFxzKVxcJCg/IVxcJCkvZywgKG1hdGNoLCBsYXRleCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBHRE9DU19NSSR7bWF0aC5sZW5ndGh9YDtcbiAgICAgICAgbWF0aC5wdXNoKHsgcGxhY2Vob2xkZXIsIG9yaWdpbmFsOiBtYXRjaCwgaXNEaXNwbGF5OiBmYWxzZSwgbGF0ZXg6IGxhdGV4LnRyaW0oKSB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY2xlYW5lZCwgbWF0aCB9O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNURVAgNDogRXh0cmFjdCBpbWFnZSBlbWJlZHNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBleHRyYWN0SW1hZ2VFbWJlZHMobWFya2Rvd246IHN0cmluZyk6IHsgY2xlYW5lZDogc3RyaW5nOyBpbWFnZXM6IEltYWdlRXh0cmFjdGlvbltdIH0ge1xuICAgIGNvbnN0IGltYWdlczogSW1hZ2VFeHRyYWN0aW9uW10gPSBbXTtcblxuICAgIC8vIE9ic2lkaWFuIHdpa2lsaW5rIGltYWdlczogIVtbcGF0aF1dIG9yICFbW3BhdGh8d2lkdGhPckFsdF1dXG4gICAgbGV0IGNsZWFuZWQgPSBtYXJrZG93bi5yZXBsYWNlKC8hXFxbXFxbKFteXFxdfF0rPykoPzpcXHwoW15cXF1dKikpP1xcXVxcXS9nLCAobWF0Y2gsIHBhdGgsIHNpemVPckFsdCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBHRE9DU19JTSR7aW1hZ2VzLmxlbmd0aH1gO1xuICAgICAgICBjb25zdCB2YXVsdFBhdGggPSBwYXRoLnRyaW0oKTtcbiAgICAgICAgY29uc3QgaXNTdmcgPSB2YXVsdFBhdGgudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnN2ZycpO1xuXG4gICAgICAgIGxldCB3aWR0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBhbHQgPSAnJztcbiAgICAgICAgaWYgKHNpemVPckFsdCkge1xuICAgICAgICAgICAgLy8gT2JzaWRpYW46IHxudW1iZXIgZm9yIHdpZHRoLCB8TnhOIGZvciBkaW1lbnNpb25zLCB8dGV4dCBmb3IgYWx0XG4gICAgICAgICAgICBpZiAoL15cXGQrKD86eFxcZCspPyQvLnRlc3Qoc2l6ZU9yQWx0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNpemVPckFsdC50cmltKCkuc3BsaXQoJ3gnKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWx0ID0gc2l6ZU9yQWx0LnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlcy5wdXNoKHsgcGxhY2Vob2xkZXIsIG9yaWdpbmFsOiBtYXRjaCwgdmF1bHRQYXRoLCBhbHQsIHdpZHRoLCBpc1N2ZyB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gU3RhbmRhcmQgbWFya2Rvd24gaW1hZ2VzOiAhW2FsdF0ocGF0aClcbiAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC8hXFxbKFteXFxdXSopXFxdXFwoKFteKV0rKVxcKS9nLCAobWF0Y2gsIGFsdCwgcGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBHRE9DU19JTSR7aW1hZ2VzLmxlbmd0aH1gO1xuICAgICAgICBjb25zdCB2YXVsdFBhdGggPSBkZWNvZGVVUklDb21wb25lbnQocGF0aC50cmltKCkpO1xuICAgICAgICBjb25zdCBpc1N2ZyA9IHZhdWx0UGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuc3ZnJyk7XG5cbiAgICAgICAgaW1hZ2VzLnB1c2goeyBwbGFjZWhvbGRlciwgb3JpZ2luYWw6IG1hdGNoLCB2YXVsdFBhdGgsIGFsdDogYWx0IHx8ICcnLCB3aWR0aDogbnVsbCwgaXNTdmcgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNsZWFuZWQsIGltYWdlcyB9O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNURVAgNTogUmVuZGVyIE1hcmtkb3duIHRvIEhUTUwgdmlhIE9ic2lkaWFuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyTWFya2Rvd25Ub0h0bWwoXG4gICAgYXBwOiBBcHAsXG4gICAgbWFya2Rvd246IHN0cmluZyxcbiAgICBzb3VyY2VQYXRoOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoKTtcbiAgICBjb21wb25lbnQubG9hZCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIoYXBwLCBtYXJrZG93biwgY29udGFpbmVyLCBzb3VyY2VQYXRoLCBjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wb25lbnQudW5sb2FkKCk7XG4gICAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNURVAgNjogUmVzdG9yZSBMYVRlWCBpbiBIVE1MXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlTWF0aEluSHRtbChodG1sOiBzdHJpbmcsIG1hdGg6IE1hdGhFeHRyYWN0aW9uW10pOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSBodG1sO1xuICAgIGZvciAoY29uc3QgbSBvZiBtYXRoKSB7XG4gICAgICAgIGNvbnN0IGxhdGV4SHRtbCA9IGVzY2FwZUh0bWwobS5sYXRleCk7XG4gICAgICAgIC8vIFVzZSBcXCguLi5cXCkgYW5kIFxcWy4uLlxcXSBkZWxpbWl0ZXJzIGluc3RlYWQgb2YgJC4uLiQgYW5kICQkLi4uJCRcbiAgICAgICAgLy8gVGhlc2UgYXJlIHVuYW1iaWd1b3VzIHR3by1jaGFyYWN0ZXIgc2VxdWVuY2VzIHRoYXQgd29uJ3QgYmUgY29uZnVzZWRcbiAgICAgICAgLy8gd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggcGFyZW50aGVzZXMsIGN1cnJlbmN5LCBldGMuXG4gICAgICAgIC8vIFRoZSBBdXRvLUxhVGVYIEVxdWF0aW9ucyBhZGQtb24gc3VwcG9ydHMgYm90aCBkZWxpbWl0ZXIgc3R5bGVzLlxuICAgICAgICBjb25zdCByZXN0b3JlZCA9IG0uaXNEaXNwbGF5ID8gYFxcXFxbJHtsYXRleEh0bWx9XFxcXF1gIDogYFxcXFwoJHtsYXRleEh0bWx9XFxcXClgO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3BsaXQobS5wbGFjZWhvbGRlcikuam9pbihyZXN0b3JlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU1RFUCA3OiBVcGxvYWQgaW1hZ2VzIGFuZCByZXN0b3JlIGluIEhUTUxcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQW5kUmVzdG9yZUltYWdlcyhcbiAgICBodG1sOiBzdHJpbmcsXG4gICAgaW1hZ2VFeHRyYWN0aW9uczogSW1hZ2VFeHRyYWN0aW9uW10sXG4gICAgYXBwOiBBcHAsXG4gICAgZmlsZTogVEZpbGUsXG4gICAgdXBsb2FkSW1hZ2VGbjogKGRhdGE6IEFycmF5QnVmZmVyLCBuYW1lOiBzdHJpbmcsIG1pbWVUeXBlOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPixcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgbGV0IHJlc3VsdCA9IGh0bWw7XG5cbiAgICAvLyBQcm9jZXNzIGluIGJhdGNoZXMgb2YgNSBmb3IgcGFyYWxsZWwgdXBsb2Fkc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VFeHRyYWN0aW9ucy5sZW5ndGg7IGkgKz0gNSkge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGltYWdlRXh0cmFjdGlvbnMuc2xpY2UoaSwgaSArIDUpO1xuICAgICAgICBjb25zdCB1cGxvYWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBiYXRjaC5tYXAoYXN5bmMgKGltZykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnZhdWx0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSBub3QgZm91bmQgaW4gdmF1bHQ6ICR7aW1nLnZhdWx0UGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGltZywgdGFnOiBgPGVtPltJbWFnZSBub3QgZm91bmQ6ICR7aW1nLnZhdWx0UGF0aH1dPC9lbT5gIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VEYXRhID0gYXdhaXQgYXBwLnZhdWx0LnJlYWRCaW5hcnkoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlID0gaW1nLmlzU3ZnID8gJ2ltYWdlL3BuZycgOiBgaW1hZ2UvJHtpbWFnZUZpbGUuZXh0ZW5zaW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IGltYWdlRmlsZS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNWR3MgbXVzdCBiZSByYXN0ZXJpemVkIChHb29nbGUgRG9jcyBkb2Vzbid0IHN1cHBvcnQgaW5saW5lIFNWRylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltZy5pc1N2Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gYXdhaXQgcmFzdGVyaXplU3ZnVG9QbmcoaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUucmVwbGFjZSgvXFwuc3ZnJC9pLCAnLnBuZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09PSAnaW1hZ2UvanBnJykgbWltZVR5cGUgPSAnaW1hZ2UvanBlZyc7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVibGljVXJsID0gYXdhaXQgdXBsb2FkSW1hZ2VGbihpbWFnZURhdGEsIGZpbGVOYW1lLCBtaW1lVHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZyA9IGA8aW1nIHNyYz1cIiR7cHVibGljVXJsfVwiIGFsdD1cIiR7ZXNjYXBlSHRtbChpbWcuYWx0IHx8IGltYWdlRmlsZS5iYXNlbmFtZSl9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1nLndpZHRoKSB0YWcgKz0gYCB3aWR0aD1cIiR7aW1nLndpZHRofVwiYDtcbiAgICAgICAgICAgICAgICAgICAgdGFnICs9IGAgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIj5gO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGltZywgdGFnIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIGltYWdlICR7aW1nLnZhdWx0UGF0aH06YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW1nLCB0YWc6IGA8ZW0+W0ZhaWxlZCB0byB1cGxvYWQ6ICR7aW1nLnZhdWx0UGF0aH1dPC9lbT5gIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCByIG9mIHVwbG9hZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyIG1heSBiZSB3cmFwcGVkIGluIDxwPiB0YWdzIChibG9jay1sZXZlbCBpbWFnZSBvbiBpdHMgb3duIGxpbmUpXG4gICAgICAgICAgICBjb25zdCBibG9ja1BhdHRlcm4gPSBgPHA+JHtyLmltZy5wbGFjZWhvbGRlcn08L3A+YDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaW5jbHVkZXMoYmxvY2tQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zcGxpdChibG9ja1BhdHRlcm4pLmpvaW4oci50YWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3BsaXQoci5pbWcucGxhY2Vob2xkZXIpLmpvaW4oci50YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTVkcgXHUyMTkyIFBORyBSYXN0ZXJpemF0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBSYXN0ZXJpemUgYW4gU1ZHIHRvIFBORyB1c2luZyB0aGUgRWxlY3Ryb24gQ2FudmFzIEFQSS5cbiAqIFJldHVybnMgdGhlIFBORyBkYXRhIGFzIGFuIEFycmF5QnVmZmVyLlxuICovXG5hc3luYyBmdW5jdGlvbiByYXN0ZXJpemVTdmdUb1BuZyhzdmdEYXRhOiBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBjb25zdCBzdmdTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoc3ZnRGF0YSk7XG5cbiAgICAvLyBQYXJzZSBkaW1lbnNpb25zIGZyb20gdGhlIFNWR1xuICAgIGxldCB3aWR0aCA9IDgwMDtcbiAgICBsZXQgaGVpZ2h0ID0gNjAwO1xuXG4gICAgY29uc3Qgdmlld0JveE1hdGNoID0gc3ZnU3RyaW5nLm1hdGNoKC92aWV3Qm94PVwiKFteXCJdKylcIi8pO1xuICAgIGlmICh2aWV3Qm94TWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB2aWV3Qm94TWF0Y2hbMV0uc3BsaXQoL1tcXHMsXSsvKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGFydHNbM107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBsaWNpdCB3aWR0aC9oZWlnaHQgb3ZlcnJpZGUgdmlld0JveFxuICAgIGNvbnN0IHdpZHRoTWF0Y2ggPSBzdmdTdHJpbmcubWF0Y2goL3dpZHRoPVwiKFxcZCsoPzpcXC5cXGQrKT8pKD86cHgpP1wiLyk7XG4gICAgY29uc3QgaGVpZ2h0TWF0Y2ggPSBzdmdTdHJpbmcubWF0Y2goL2hlaWdodD1cIihcXGQrKD86XFwuXFxkKyk/KSg/OnB4KT9cIi8pO1xuICAgIGlmICh3aWR0aE1hdGNoKSB3aWR0aCA9IHBhcnNlRmxvYXQod2lkdGhNYXRjaFsxXSk7XG4gICAgaWYgKGhlaWdodE1hdGNoKSBoZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodE1hdGNoWzFdKTtcblxuICAgIC8vIDJ4IHNjYWxlIGZvciBjcmlzcCByZW5kZXJpbmdcbiAgICBjb25zdCBzY2FsZSA9IDI7XG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogc2NhbGUpO1xuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogc2NhbGUpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbc3ZnU3RyaW5nXSwgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04JyB9KTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBjYW52YXMgMmQgY29udGV4dCcpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoKHBuZ0Jsb2IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwbmdCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW52YXMgdG9CbG9iIHJldHVybmVkIG51bGwnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG5nQmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9LCAnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIFNWRyBpbnRvIEltYWdlIGVsZW1lbnQnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIVE1MIENsZWFudXAgZm9yIEdvb2dsZSBEb2NzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgQ0FMTE9VVF9DT0xPUlM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgbm90ZTogJyM0NDhhZmYnLFxuICAgIGFic3RyYWN0OiAnIzAwYmNkNCcsXG4gICAgc3VtbWFyeTogJyMwMGJjZDQnLFxuICAgIGluZm86ICcjMjE5NmYzJyxcbiAgICB0aXA6ICcjMDBiZmE1JyxcbiAgICBoaW50OiAnIzAwYmZhNScsXG4gICAgc3VjY2VzczogJyMwMGM4NTMnLFxuICAgIGNoZWNrOiAnIzAwYzg1MycsXG4gICAgcXVlc3Rpb246ICcjZmY5ODAwJyxcbiAgICBoZWxwOiAnI2ZmOTgwMCcsXG4gICAgd2FybmluZzogJyNmZjkxMDAnLFxuICAgIGNhdXRpb246ICcjZmY5MTAwJyxcbiAgICBmYWlsdXJlOiAnI2ZmNTI1MicsXG4gICAgZGFuZ2VyOiAnI2ZmNTI1MicsXG4gICAgZXJyb3I6ICcjZmY1MjUyJyxcbiAgICBidWc6ICcjZmY1MjUyJyxcbiAgICBleGFtcGxlOiAnIzdjNGRmZicsXG4gICAgcXVvdGU6ICcjOWU5ZTllJyxcbiAgICBjaXRlOiAnIzllOWU5ZScsXG59O1xuXG5mdW5jdGlvbiBjbGVhbkh0bWxGb3JHb29nbGVEb2NzKGh0bWw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9IGh0bWw7XG5cbiAgICAvLyBDb252ZXJ0IGNhbGxvdXQgZGl2cyB0byBzdHlsZWQgdGFibGVzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAgIC88ZGl2W14+XSpkYXRhLWNhbGxvdXQ9XCIoW15cIl0qKVwiW14+XSpjbGFzcz1cIlteXCJdKmNhbGxvdXRbXlwiXSpcIltePl0qPihbXFxzXFxTXSo/KTxcXC9kaXY+XFxzKjxcXC9kaXY+XFxzKjxcXC9kaXY+L2dpLFxuICAgICAgICAoXywgdHlwZSwgY29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBDQUxMT1VUX0NPTE9SU1t0eXBlLnRvTG93ZXJDYXNlKCldIHx8ICcjNDQ4YWZmJztcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGRpdltePl0qY2xhc3M9XCJbXlwiXSpjYWxsb3V0LXRpdGxlW15cIl0qXCJbXj5dKj4vZ2ksICc8Yj4nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88ZGl2W14+XSpjbGFzcz1cIlteXCJdKmNhbGxvdXQtY29udGVudFteXCJdKlwiW14+XSo+L2dpLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPFxcL2Rpdj4vZ2ksICc8L2I+PGJyLz4nKTtcbiAgICAgICAgICAgIHJldHVybiBgPHRhYmxlIHN0eWxlPVwiYm9yZGVyLWxlZnQ6NHB4IHNvbGlkICR7Y29sb3J9O2JhY2tncm91bmQ6I2Y4ZjlmYTt3aWR0aDoxMDAlO21hcmdpbjoxMnB4IDA7XCI+XG4gICAgICAgICAgICAgICAgPHRyPjx0ZCBzdHlsZT1cInBhZGRpbmc6MTJweDtcIj4ke2NsZWFuQ29udGVudH08L3RkPjwvdHI+PC90YWJsZT5gO1xuICAgICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBDb252ZXJ0IHdpa2lsaW5rcyB0byBib2xkIHRleHRcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShcbiAgICAgICAgLzxhW14+XSpjbGFzcz1cIlteXCJdKmludGVybmFsLWxpbmtbXlwiXSpcIltePl0qPiguKj8pPFxcL2E+L2dpLFxuICAgICAgICAnPGI+JDE8L2I+JyxcbiAgICApO1xuXG4gICAgLy8gSW5saW5lIHN0eWxlcyBmb3IgY29kZSBibG9ja3NcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShcbiAgICAgICAgLzxwcmU+L2dpLFxuICAgICAgICAnPHByZSBzdHlsZT1cImJhY2tncm91bmQ6I2Y1ZjVmNTtwYWRkaW5nOjE2cHg7Ym9yZGVyLXJhZGl1czo0cHg7Zm9udC1mYW1pbHk6XFwnQ291cmllciBOZXdcXCcsbW9ub3NwYWNlO3doaXRlLXNwYWNlOnByZTtvdmVyZmxvdy14OmF1dG87Zm9udC1zaXplOjEzcHg7XCI+JyxcbiAgICApO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKFxuICAgICAgICAvPGNvZGU+L2dpLFxuICAgICAgICAnPGNvZGUgc3R5bGU9XCJiYWNrZ3JvdW5kOiNmNWY1ZjU7cGFkZGluZzoycHggNHB4O2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtZmFtaWx5OlxcJ0NvdXJpZXIgTmV3XFwnLG1vbm9zcGFjZTtmb250LXNpemU6MTNweDtcIj4nLFxuICAgICk7XG5cbiAgICAvLyBJbmxpbmUgc3R5bGVzIGZvciBibG9ja3F1b3Rlc1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKFxuICAgICAgICAvPGJsb2NrcXVvdGU+L2dpLFxuICAgICAgICAnPGJsb2NrcXVvdGUgc3R5bGU9XCJib3JkZXItbGVmdDo0cHggc29saWQgI2NjYztwYWRkaW5nLWxlZnQ6MTZweDttYXJnaW4tbGVmdDowO2NvbG9yOiM2NjY7XCI+JyxcbiAgICApO1xuXG4gICAgLy8gSW5saW5lIHN0eWxlcyBmb3IgdGFibGVzIChvbmx5IHRob3NlIHdpdGhvdXQgZXhpc3Rpbmcgc3R5bGUpXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAgIC88dGFibGUoPyFbXj5dKnN0eWxlKS9naSxcbiAgICAgICAgJzx0YWJsZSBzdHlsZT1cImJvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTt3aWR0aDoxMDAlO21hcmdpbjoxMnB4IDA7XCInLFxuICAgICk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAgIC88dGgoPyFbXj5dKnN0eWxlKS9naSxcbiAgICAgICAgJzx0aCBzdHlsZT1cImJvcmRlcjoxcHggc29saWQgI2RkZDtwYWRkaW5nOjhweDtiYWNrZ3JvdW5kOiNmNWY1ZjU7dGV4dC1hbGlnbjpsZWZ0O1wiJyxcbiAgICApO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKFxuICAgICAgICAvPHRkKD8hW14+XSpzdHlsZSkvZ2ksXG4gICAgICAgICc8dGQgc3R5bGU9XCJib3JkZXI6MXB4IHNvbGlkICNkZGQ7cGFkZGluZzo4cHg7XCInLFxuICAgICk7XG5cbiAgICAvLyBTdHJpcCBPYnNpZGlhbi1zcGVjaWZpYyBjbGFzcyBhbmQgZGF0YSBhdHRyaWJ1dGVzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccytjbGFzcz1cIlteXCJdKlwiL2dpLCAnJyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccytkYXRhLVthLXotXSs9XCJbXlwiXSpcIi9naSwgJycpO1xuXG4gICAgLy8gQ2xlYW4gdXAgZW1wdHkgcGFyYWdyYXBoc1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC88cD5cXHMqPFxcL3A+L2dpLCAnJyk7XG5cbiAgICAvLyBSZW1vdmUgYW55IGxlZnRvdmVyIE1hdGhKYXggY29udGFpbmVycyB0aGUgcmVuZGVyZXIgbWF5IGhhdmUgcHJvZHVjZWRcbiAgICAvLyAodGhlaXIgY29udGVudCBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgb3VyIHByZS1leHRyYWN0aW9uKVxuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC88bWp4LWNvbnRhaW5lcltePl0qPltcXHNcXFNdKj88XFwvbWp4LWNvbnRhaW5lcj4vZ2ksICcnKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRnVsbCBQaXBlbGluZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ29udmVydCBhbiBPYnNpZGlhbiBub3RlIHRvIGNsZWFuIEhUTUwgcmVhZHkgZm9yIEdvb2dsZSBEb2NzLlxuICpcbiAqIEBwYXJhbSBhcHAgLSBPYnNpZGlhbiBBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIG1hcmtkb3duIGZpbGUgdG8gY29udmVydFxuICogQHBhcmFtIHVwbG9hZEltYWdlRm4gLSBDYWxsYmFjayB0byB1cGxvYWQgYW4gaW1hZ2UgYW5kIHJldHVybiBpdHMgcHVibGljIFVSTFxuICogQHJldHVybnMgQ29tcGxldGUgSFRNTCBkb2N1bWVudCBzdHJpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnROb3RlVG9IdG1sKFxuICAgIGFwcDogQXBwLFxuICAgIGZpbGU6IFRGaWxlLFxuICAgIHVwbG9hZEltYWdlRm46IChkYXRhOiBBcnJheUJ1ZmZlciwgbmFtZTogc3RyaW5nLCBtaW1lVHlwZTogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz4sXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIDEuIFJlYWQgYW5kIHN0cmlwIGZyb250bWF0dGVyXG4gICAgY29uc3QgcmF3TWFya2Rvd24gPSBhd2FpdCBhcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICBjb25zdCBtYXJrZG93biA9IHN0cmlwRnJvbnRtYXR0ZXIocmF3TWFya2Rvd24pO1xuXG4gICAgLy8gMi4gUHJvdGVjdCBjb2RlIGJsb2NrcyBmcm9tIHJlZ2V4ICh0ZW1wb3JhcnkgZXh0cmFjdGlvbilcbiAgICBjb25zdCB7IGNsZWFuZWQ6IG5vQ29kZU1kLCBibG9ja3M6IGNvZGVCbG9ja3MgfSA9IGV4dHJhY3RDb2RlQmxvY2tzKG1hcmtkb3duKTtcblxuICAgIC8vIDMuIEV4dHJhY3QgTGFUZVggbWF0aCBcdTIxOTIgcGxhY2Vob2xkZXJzXG4gICAgY29uc3QgeyBjbGVhbmVkOiBub01hdGhNZCwgbWF0aDogbWF0aEV4dHJhY3Rpb25zIH0gPSBleHRyYWN0TWF0aChub0NvZGVNZCk7XG5cbiAgICAvLyA0LiBFeHRyYWN0IGltYWdlIGVtYmVkcyBcdTIxOTIgcGxhY2Vob2xkZXJzXG4gICAgY29uc3QgeyBjbGVhbmVkOiBub0ltZ01kLCBpbWFnZXM6IGltYWdlRXh0cmFjdGlvbnMgfSA9IGV4dHJhY3RJbWFnZUVtYmVkcyhub01hdGhNZCk7XG5cbiAgICAvLyA1LiBSZXN0b3JlIGNvZGUgYmxvY2tzIChPYnNpZGlhbiBuZWVkcyB0aGVtIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nKVxuICAgIGNvbnN0IHJlbmRlck1kID0gcmVzdG9yZUV4dHJhY3Rpb25zKG5vSW1nTWQsIGNvZGVCbG9ja3MpO1xuXG4gICAgY29uc29sZS5sb2coYGNvbnZlcnROb3RlVG9IdG1sOiBleHRyYWN0ZWQgJHttYXRoRXh0cmFjdGlvbnMubGVuZ3RofSBtYXRoLCAke2ltYWdlRXh0cmFjdGlvbnMubGVuZ3RofSBpbWFnZXNgKTtcblxuICAgIC8vIDYuIFJlbmRlciBtYXJrZG93biB0byBIVE1MIHZpYSBPYnNpZGlhblxuICAgIC8vICAgIE1hdGggcGxhY2Vob2xkZXJzIGJlY29tZSBwbGFpbiB0ZXh0OyBpbWFnZSBwbGFjZWhvbGRlcnMgYmVjb21lIHBsYWluIHRleHQuXG4gICAgLy8gICAgTm8gTWF0aEpheCByZW5kZXJpbmcgKG5vICQgZGVsaW1pdGVycyksIG5vIGltYWdlIGxvYWRpbmcgKG5vICFbW11dIHN5bnRheCkuXG4gICAgbGV0IGh0bWwgPSBhd2FpdCByZW5kZXJNYXJrZG93blRvSHRtbChhcHAsIHJlbmRlck1kLCBmaWxlLnBhdGgpO1xuXG4gICAgLy8gNy4gUmVzdG9yZSBMYVRlWCAocGxhY2Vob2xkZXJzIFx1MjE5MiByYXcgJExhVGVYJCAvICQkTGFUZVgkJCB0ZXh0KVxuICAgIGh0bWwgPSByZXN0b3JlTWF0aEluSHRtbChodG1sLCBtYXRoRXh0cmFjdGlvbnMpO1xuXG4gICAgLy8gOC4gVXBsb2FkIGltYWdlcyBhbmQgcmVzdG9yZSAocGxhY2Vob2xkZXJzIFx1MjE5MiA8aW1nIHNyYz1cImRyaXZlX3VybFwiPilcbiAgICBodG1sID0gYXdhaXQgcHJvY2Vzc0FuZFJlc3RvcmVJbWFnZXMoaHRtbCwgaW1hZ2VFeHRyYWN0aW9ucywgYXBwLCBmaWxlLCB1cGxvYWRJbWFnZUZuKTtcblxuICAgIC8vIDkuIENsZWFuIEhUTUwgZm9yIEdvb2dsZSBEb2NzIGNvbXBhdGliaWxpdHlcbiAgICBodG1sID0gY2xlYW5IdG1sRm9yR29vZ2xlRG9jcyhodG1sKTtcblxuICAgIC8vIDEwLiBXcmFwIGluIGEgY29tcGxldGUgSFRNTCBkb2N1bWVudFxuICAgIGNvbnN0IHRpdGxlID0gZmlsZS5iYXNlbmFtZTtcbiAgICByZXR1cm4gYDwhRE9DVFlQRSBodG1sPlxuPGh0bWw+XG48aGVhZD5cbjxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuPHRpdGxlPiR7dGl0bGV9PC90aXRsZT5cbjwvaGVhZD5cbjxib2R5IHN0eWxlPVwiZm9udC1mYW1pbHk6QXJpYWwsc2Fucy1zZXJpZjttYXgtd2lkdGg6ODAwcHg7bWFyZ2luOmF1dG87bGluZS1oZWlnaHQ6MS42O1wiPlxuPGgxPiR7dGl0bGV9PC9oMT5cbiR7aHRtbH1cbjwvYm9keT5cbjwvaHRtbD5gO1xufVxuIiwgIi8vIGdvb2dsZS1hcGkudHMgXHUyMDE0IEdvb2dsZSBEcml2ZSBBUEkgaW50ZXJhY3Rpb25zXG4vL1xuLy8gVXNlcyBPYnNpZGlhbidzIHJlcXVlc3RVcmwoKSB3aGljaCBieXBhc3NlcyBDT1JTIHJlc3RyaWN0aW9ucy5cbi8vIEFsbCBmdW5jdGlvbnMgcmVxdWlyZSBhIHZhbGlkIE9BdXRoIGFjY2VzcyB0b2tlbi5cblxuaW1wb3J0IHsgcmVxdWVzdFVybCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7XG4gICAgRFJJVkVfVVBMT0FEX1VSTCxcbiAgICBEUklWRV9GSUxFU19VUkwsXG4gICAgRHJpdmVGaWxlUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyAtLS0tIEhlbHBlcnMgLS0tLVxuXG4vKiogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgQXJyYXlCdWZmZXJzIGludG8gb25lICovXG5mdW5jdGlvbiBjb25jYXRBcnJheUJ1ZmZlcnMoLi4uYnVmZmVyczogQXJyYXlCdWZmZXJbXSk6IEFycmF5QnVmZmVyIHtcbiAgICBjb25zdCB0b3RhbExlbmd0aCA9IGJ1ZmZlcnMucmVkdWNlKChzdW0sIGJ1ZikgPT4gc3VtICsgYnVmLmJ5dGVMZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBidWZmZXJzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cblxuLyoqIEVuY29kZSBhIHN0cmluZyBhcyBVVEYtOCBBcnJheUJ1ZmZlciAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUJ1ZmZlcihzdHI6IHN0cmluZyk6IEFycmF5QnVmZmVyIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikuYnVmZmVyO1xufVxuXG4vKiogRXh0cmFjdCBHb29nbGUgRG9jIElEIGZyb20gYSBHb29nbGUgRG9jcyBVUkwgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RG9jSWQodXJsOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvXFwvZFxcLyhbYS16QS1aMC05LV9dKykvKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG5cbi8vIC0tLS0gQ3JlYXRlIEdvb2dsZSBEb2MgZnJvbSBIVE1MIC0tLS1cblxuLyoqXG4gKiBVcGxvYWQgSFRNTCBjb250ZW50IHRvIEdvb2dsZSBEcml2ZSwgYXV0by1jb252ZXJ0aW5nIHRvIGEgR29vZ2xlIERvYy5cbiAqIFJldHVybnMgdGhlIG5ldyBkb2N1bWVudCdzIG1ldGFkYXRhIGluY2x1ZGluZyBpdHMgd2ViVmlld0xpbmsuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVHb29nbGVEb2MoXG4gICAgYWNjZXNzVG9rZW46IHN0cmluZyxcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgaHRtbENvbnRlbnQ6IHN0cmluZyxcbiAgICBmb2xkZXJJZD86IHN0cmluZyxcbik6IFByb21pc2U8RHJpdmVGaWxlUmVzcG9uc2U+IHtcbiAgICBjb25zdCBib3VuZGFyeSA9ICctLS0tUHVibGlzaFRvR0RvY3MnICsgRGF0ZS5ub3coKTtcblxuICAgIC8vIE1ldGFkYXRhIHBhcnQ6IHRlbGwgRHJpdmUgdG8gY3JlYXRlIGEgR29vZ2xlIERvY1xuICAgIGNvbnN0IG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnLFxuICAgIH07XG4gICAgaWYgKGZvbGRlcklkKSB7XG4gICAgICAgIG1ldGFkYXRhLnBhcmVudHMgPSBbZm9sZGVySWRdO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIG11bHRpcGFydC9yZWxhdGVkIGJvZHkgYXMgYSBzdHJpbmdcbiAgICAvLyAoYm90aCBwYXJ0cyBhcmUgdGV4dCwgc28gc3RyaW5nIGNvbmNhdGVuYXRpb24gd29ya3MpXG4gICAgY29uc3QgYm9keSA9IFtcbiAgICAgICAgYC0tJHtib3VuZGFyeX1cXHJcXG5gLFxuICAgICAgICAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04XFxyXFxuXFxyXFxuJyxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICBgXFxyXFxuLS0ke2JvdW5kYXJ5fVxcclxcbmAsXG4gICAgICAgICdDb250ZW50LVR5cGU6IHRleHQvaHRtbDsgY2hhcnNldD1VVEYtOFxcclxcblxcclxcbicsXG4gICAgICAgIGh0bWxDb250ZW50LFxuICAgICAgICBgXFxyXFxuLS0ke2JvdW5kYXJ5fS0tYCxcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgICAgdXJsOiBgJHtEUklWRV9VUExPQURfVVJMfT91cGxvYWRUeXBlPW11bHRpcGFydCZmaWVsZHM9aWQsbmFtZSx3ZWJWaWV3TGluayxtaW1lVHlwZWAsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IGBtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JHtib3VuZGFyeX1gLFxuICAgICAgICB9LFxuICAgICAgICBib2R5LFxuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmpzb247XG4gICAgaWYgKCFkYXRhLmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBHb29nbGUgRG9jOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHdlYlZpZXdMaW5rOiBkYXRhLndlYlZpZXdMaW5rLFxuICAgICAgICBtaW1lVHlwZTogZGF0YS5taW1lVHlwZSxcbiAgICB9O1xufVxuXG4vLyAtLS0tIERlbGV0ZSBhIEdvb2dsZSBEb2MgLS0tLVxuXG4vKipcbiAqIERlbGV0ZSBhIGZpbGUgZnJvbSBHb29nbGUgRHJpdmUgYnkgaXRzIGZpbGUgSUQuXG4gKiBTaWxlbnRseSBzdWNjZWVkcyBpZiB0aGUgZmlsZSBpcyBhbHJlYWR5IGdvbmUgKDQwNCkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVHb29nbGVEb2MoXG4gICAgYWNjZXNzVG9rZW46IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBgJHtEUklWRV9GSUxFU19VUkx9LyR7ZmlsZUlkfWAsXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH0sXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgICAvLyA0MDQgPSBhbHJlYWR5IGRlbGV0ZWQsIHRoYXQncyBmaW5lXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IChlcnIgYXMgeyBzdGF0dXM/OiBudW1iZXIgfSkuc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzICE9PSA0MDQpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gLS0tLSBVcGxvYWQgSW1hZ2UgdG8gRHJpdmUgLS0tLVxuXG4vKipcbiAqIFVwbG9hZCBhIGJpbmFyeSBpbWFnZSB0byBHb29nbGUgRHJpdmUgYW5kIG1ha2UgaXQgcHVibGljbHkgYWNjZXNzaWJsZS5cbiAqIFJldHVybnMgYSBkaXJlY3QtYWNjZXNzIFVSTCBzdWl0YWJsZSBmb3IgdXNlIGluIDxpbWc+IHRhZ3MuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRJbWFnZVRvRHJpdmUoXG4gICAgYWNjZXNzVG9rZW46IHN0cmluZyxcbiAgICBpbWFnZURhdGE6IEFycmF5QnVmZmVyLFxuICAgIGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgbWltZVR5cGU6IHN0cmluZyxcbiAgICBmb2xkZXJJZD86IHN0cmluZyxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYm91bmRhcnkgPSAnLS0tLVB1Ymxpc2hUb0dEb2NzSW1nJyArIERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgIC8vIEJ1aWxkIG1ldGFkYXRhXG4gICAgY29uc3QgbWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0geyBuYW1lOiBmaWxlTmFtZSB9O1xuICAgIGlmIChmb2xkZXJJZCkge1xuICAgICAgICBtZXRhZGF0YS5wYXJlbnRzID0gW2ZvbGRlcklkXTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBtdWx0aXBhcnQgYm9keSBhcyBBcnJheUJ1ZmZlciAobWl4aW5nIHRleHQgKyBiaW5hcnkpXG4gICAgY29uc3QgbWV0YWRhdGFQYXJ0ID0gW1xuICAgICAgICBgLS0ke2JvdW5kYXJ5fVxcclxcbmAsXG4gICAgICAgICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLThcXHJcXG5cXHJcXG4nLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSksXG4gICAgICAgICdcXHJcXG4nLFxuICAgIF0uam9pbignJyk7XG5cbiAgICBjb25zdCBpbWFnZVBhcnQgPSBbXG4gICAgICAgIGAtLSR7Ym91bmRhcnl9XFxyXFxuYCxcbiAgICAgICAgYENvbnRlbnQtVHlwZTogJHttaW1lVHlwZX1cXHJcXG5gLFxuICAgICAgICAnQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogYmluYXJ5XFxyXFxuXFxyXFxuJyxcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgY29uc3QgY2xvc2luZyA9IGBcXHJcXG4tLSR7Ym91bmRhcnl9LS1gO1xuXG4gICAgY29uc3QgYm9keSA9IGNvbmNhdEFycmF5QnVmZmVycyhcbiAgICAgICAgc3RyaW5nVG9BcnJheUJ1ZmZlcihtZXRhZGF0YVBhcnQpLFxuICAgICAgICBzdHJpbmdUb0FycmF5QnVmZmVyKGltYWdlUGFydCksXG4gICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgc3RyaW5nVG9BcnJheUJ1ZmZlcihjbG9zaW5nKSxcbiAgICApO1xuXG4gICAgLy8gVXBsb2FkIHRoZSBpbWFnZVxuICAgIGNvbnN0IHVwbG9hZFJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgIHVybDogYCR7RFJJVkVfVVBMT0FEX1VSTH0/dXBsb2FkVHlwZT1tdWx0aXBhcnQmZmllbGRzPWlkYCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHksXG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWxlSWQgPSB1cGxvYWRSZXNwb25zZS5qc29uLmlkO1xuICAgIGlmICghZmlsZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgdXBsb2FkIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeSh1cGxvYWRSZXNwb25zZS5qc29uKX1gKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSBpbWFnZSBwdWJsaWNseSBhY2Nlc3NpYmxlIChhbnlvbmUgd2l0aCBsaW5rIGNhbiB2aWV3KVxuICAgIGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICB1cmw6IGAke0RSSVZFX0ZJTEVTX1VSTH0vJHtmaWxlSWR9L3Blcm1pc3Npb25zYCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJvbGU6ICdyZWFkZXInLCB0eXBlOiAnYW55b25lJyB9KSxcbiAgICB9KTtcblxuICAgIC8vIFJldHVybiBhIGRpcmVjdC1hY2Nlc3MgVVJMIHRoYXQgd29ya3MgaW4gPGltZz4gdGFnc1xuICAgIHJldHVybiBgaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL3VjP2lkPSR7ZmlsZUlkfSZleHBvcnQ9ZG93bmxvYWRgO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQSxJQUFBQSxtQkFLTzs7O0FDSUEsSUFBTSxtQkFBbUM7QUFBQSxFQUM1QyxVQUFVO0FBQUEsRUFDVixjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsRUFDYixjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsRUFDYixXQUFXO0FBQUEsRUFDWCxpQkFBaUI7QUFDckI7QUFJTyxJQUFNLGtCQUFrQjtBQUN4QixJQUFNLG1CQUFtQjtBQUN6QixJQUFNLHNCQUFzQjtBQUM1QixJQUFNLG1CQUFtQjtBQUN6QixJQUFNLGtCQUFrQjtBQUd4QixJQUFNLFNBQVM7OztBQzNCdEIsSUFBQUMsbUJBQXVEOzs7QUNBdkQsc0JBQW1DO0FBVW5DLFdBQXNCO0FBQ3RCLGFBQXdCO0FBS3hCLFNBQVMsdUJBQStCO0FBQ3BDLFFBQU0sUUFBZSxtQkFBWSxFQUFFO0FBQ25DLFNBQU8sTUFDRixTQUFTLFFBQVEsRUFDakIsUUFBUSxPQUFPLEdBQUcsRUFDbEIsUUFBUSxPQUFPLEdBQUcsRUFDbEIsUUFBUSxNQUFNLEVBQUUsRUFDaEIsTUFBTSxHQUFH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QUFBQSxJQUMzQixDQUFDO0FBR0QsbUJBQWUsS0FBSztBQUNwQixRQUFJLHdCQUFPO0FBQUEsRUFBOEIsT0FBTyxXQUFXLElBQUksR0FBSztBQUdwRSxXQUFPLEtBQUssT0FBTyxXQUFXO0FBQUEsRUFFbEMsU0FBUyxLQUFLO0FBQ1YsbUJBQWUsS0FBSztBQUdwQixVQUFNLFNBQVUsSUFBNEI7QUFDNUMsUUFBSSxXQUFXLE9BQU8sV0FBVyxLQUFLO0FBQ2xDLFVBQUksd0JBQU8sZ0RBQWdEO0FBQzNELGFBQU8sU0FBUyxjQUFjO0FBQzlCLGFBQU8sU0FBUyxjQUFjO0FBQzlCLFlBQU0sT0FBTyxhQUFhO0FBRzFCLFVBQUk7QUFDQSxjQUFNLFlBQVksUUFBUSxJQUFJO0FBQUEsTUFDbEMsU0FBUyxVQUFVO0FBQ2YsWUFBSSx3QkFBTywrQkFBZ0MsU0FBbUIsT0FBTyxFQUFFO0FBQUEsTUFDM0U7QUFDQTtBQUFBLElBQ0o7QUFFQSxRQUFJLHdCQUFPLG1CQUFvQixJQUFjLE9BQU8sRUFBRTtBQUN0RCxZQUFRLE1BQU0saUNBQWlDLEdBQUc7QUFBQSxFQUN0RDtBQUNKOzs7QUpqTkEsSUFBcUIsNEJBQXJCLGNBQXVELHdCQUFPO0FBQUEsRUFBOUQ7QUFBQTtBQUNJLG9CQUEyQjtBQUFBO0FBQUEsRUFFM0IsTUFBTSxTQUF3QjtBQUMxQixVQUFNLEtBQUssYUFBYTtBQUd4QixTQUFLLGNBQWMsSUFBSSxrQkFBa0IsS0FBSyxLQUFLLElBQUksQ0FBQztBQUd4RCxTQUFLO0FBQUEsTUFDRCxLQUFLLElBQUksVUFBVSxHQUFHLGFBQWEsQ0FBQyxNQUFNLFNBQXdCO0FBRTlELFlBQUksRUFBRSxnQkFBZ0Isd0JBQVE7QUFDOUIsWUFBSSxLQUFLLGNBQWMsS0FBTTtBQUU3QixhQUFLLFFBQVEsQ0FBQyxTQUFTO0FBQ25CLGVBQUssU0FBUyx3QkFBd0IsRUFDakMsUUFBUSxjQUFjLEVBQ3RCLFFBQVEsWUFBWTtBQUNqQixnQkFBSTtBQUNBLG9CQUFNLFlBQVksTUFBTSxJQUFJO0FBQUEsWUFDaEMsU0FBUyxLQUFLO0FBQ1Ysc0JBQVEsTUFBTSxpQ0FBaUMsR0FBRztBQUNsRCxrQkFBSSx3QkFBTyxtQkFBb0IsSUFBYyxPQUFPLEVBQUU7QUFBQSxZQUMxRDtBQUFBLFVBQ0osQ0FBQztBQUFBLFFBQ1QsQ0FBQztBQUFBLE1BQ0wsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFFQSxXQUFpQjtBQUFBLEVBRWpCO0FBQUEsRUFFQSxNQUFNLGVBQThCO0FBQ2hDLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDN0U7QUFBQSxFQUVBLE1BQU0sZUFBOEI7QUFDaEMsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDckM7QUFDSjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
